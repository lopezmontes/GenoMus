# GenoMus specifications

<img src="figures/GenoMus_figura_6-3.svg" width="160">

--------
## Table of Contents
- [Introduction](#Introduction)
- [GenoMus arquitecture overall view](#genomus-arquitecture-overall-view)
- [Definitions](#definitions)
- [Anatomy of a genotype function](#anatomy-of-a-genotype-function)
  - [Function name](#function-name)
  - [Input arguments](#input-argumentss)
  - [Output data structure](#output-data-structure)
  - [Genotype function template](#genotype-function-template)
- [Function libraries](#function-libraries)  
  - [Indexing a function in a GenoMus Function Library](#indexing-a-function-in-a-genomus-function-library)
  - [Encoded function index generation](#encoded-function-index-generation)
- [Genotype function types](#genotype-function-types)
  - [Used function type identifiers](#used-function-type-identifiers)
  - [Main structures](#main-structures)
  - [Human-readable leaf parameters](#human-readable-leaf-parameters) 
  - [Human-readable lists](#human-readable-lists) 
  - [Domain-specific formats](#domain-specific-formats)
  - [Manual manipulation of genotypes](#manual-manipulation-of-genotypes)
- [Parameter mapping](#parameter-mapping)
  - [Duration](#duration)
    - [notevalueF (n)](#notevaluef-n)
      - [Reference table for main noteValues](#Reference-table-for-main-notevalues)
    - [durationF (d)](#durationf-d)
  - [Pitch](#pitch)
    - [midipitchF (m)](#midipitchf-m)
    - [frequencyF (f)](#frequencyf-f)
  - [Articulation](#articulation)
    - [articulationF (a)](#articulationf-a)
  - [Intensity](#intensity)
    - [intensityF (i)](#intensityf-i)
  - [Quantized steps](#quantized-steps)
    - [quantizedF (q)](#quantizedf-q)   
  - [rhythmF](#rhythmf)
  - [harmonyF](#harmonyf)
- [Characterization of underlying musical patterns](#characterization-of-underlying-musical-patterns)
  - [Rhythmic grid](#rhythmic-grid)
    - [totalValue](#totalvalue)
    - [talea](#talea)
    - [prolatio](#prolatio)
    - [quantization](#quantization)
    - [Example of rhythmic motives](#example-of-rhythmic-motives)
  - [Harmonic grid](#harmonic-grid)
    - [chromaticism](#chromaticism)
    - [Example of harmonic grids](#example-of-harmonic-grids)
- [Encoding-decoding genotypes](#encoding-decoding-genotypes)
  - [Conversion table for genotypes](#conversion-table-for-genotypes)
  - [Examples](#examples)
    - [Minimal genotype](#minimal-genotype)
    - [Minimal genotype with human-readable leaf parameters](#minimal-genotype-with-human-readable-leaf-parameters)
    - [List encoding](#list-encoding)
- [Encoding-decoding phenotypes](#encoding-decoding-phenotypes)
- [Genotype substructures](#genotype-substructures)
    - [Genotype scaffolding](#genotype-scaffolding)
    - [Function network](#function-network)
    - [Leaves vector](#leaves-vector)
    - [Subexpressions](#subexpressions)
- [Initial conditions for generation of genotypes](#initial-conditions-for-generation-of-genotypes)
  - [Vector of desired musical characteristics](#vector-of-desired-musical-characteristics)
    - [Weighted measurement of Euclidean distance](#weighted-measurement-of-euclidean-distance)
- [Specimen data structure](#specimen-data-structure)
- [Specimen catalogue](#specimen-catalogue)
  - [Naming](#naming)
  - [Classification](#classification)
  - [Catalogue access](#catalogue-access)
- [Max user interface](#max-user-interface)
----------  
# Definitions
- **genotype**: Function tree representing compositional procedures.
- **phenotype**: Music score generated by a genotype.
- **encoded genotype**: Genotype coded as an array of normalized floats within the closed interval [0, 1].
- **decoded genotype**: Genotype coded as a string that contains a function tree, executable in JavaScript.
- **encoded phenotype**: Phenotype coded as an array of normalized floats within the closed interval [0, 1].
- **decoded phenotype**: Phenotype converted to a format for notation or audio software, such as Max, Csound, Lilypond, etc.
- **specimen**: Genotype/phenotype pair, saved as a JSON file containing encoded and decoded versions of its code, metadata and many other useful analytical informations.
- **species**: Group of specimens that share the same parameter structure of their simplest musical events.
- **genotype function**: Minimum computable unit of a genotype. It is designed in a modular way to easily take other genotype functions as arguments.
- **parameter**: Normalized float &isinv; [0, 1] used to feed the functions' required arguments. These numeric values are leaves of the functional tree that gives rise to a genotype.
- **leaf**: Terminal node of a genotype functional tree, containing a parameter.
- **list**: Array of parameters.
- **event**: Simplest sonic element. In traditional music writing, a note. The default atributes of an event are: [duration, pitch, articulation, intensity]. An event can contain more than one pitch. events with more parameters can be set, for example, for electroacoustic works, where a sonic event could be defined by dozens of features. A note can consist of two or more concatenated pitches. events can be concatenated only sequentially (one after another, without overlapping). Overlapping effect among events inside the same voice can be achieved by means of articulation. An event can be extended to other domains beyond music, like visuals, lighting, etc., along with musical events, or standalone. 
- **voice**: Line of music (usually for an only instrument). A voice is a wrapper for a sequence of one or more events. A voice can consist of two or more voices sequentially concatenated  together (one after another, without overlapping). Each event inside a voice can contain more than one pitch. For instance, a sequence of major chords can be a single voice.
- **score**: Excerpt or a whole piece of music. A score is a wrapper for one or more voices. A score can consist of two or more scores together. Scores can be concatenated sequentially (one after another) or simultaneously (sounding together). The product of these concatenations is a new score. The event-voice-score structure is defined after [bach](https://www.bachproject.net/) paradigm, to facilitate the visualization and interactions with phenotypes in Max environment.
- **duration**: Time length from the beginning of an event to the beginning of the next event, into the same voice. 
- **pitch**: Each of the root frecuencies in an event.
- **articulation**: Length of the event sound. It can be different from the event duration. If articulation matchs the duration, a perfect legato among events will be played. Shorter or larger values for articulation will sound as staccato or lasciare vibrare effects.
- **intensity**: Dynamic of an event.
- **GenoMus function catalog**: JSON file that lists and characterizes all the available functions for genotype generation of a species.
- **function type identifier**: Prefix used to name functions, to ease the function type identification. The use of identifiers is not compulsory, but very convenient for readability of decoded genotypes.
- **function index**: Integer assigned incrementally to identify each function with a unique number in the GenoMus functions catalogue. 
- **encoded function index**: Float generated to identify each function with a unique number. These numbers are chosen using the function index as input for an algorithm designed to obtain an optimized distribution of these normalized identifiers &isinv; [0, 1].
- **eligible functions**: Set of functions that determine which ones can be chosen during the genotype generation process. Somehow, this set can characterize a composer or a style.
- **genotype seed**: Number used to initialize the pseudorandom number generator before the genotype generation process starts. It allows repeatable results. Ultimately, a genotype can be identified only by this number, since it determines the entire decision tree that generates it.
- **phenotype seed**: Number used to initialize the pseudorandom number generator before the genotype evaluation process starts, which allows producing repeatable phenotypes. When a genotype includes random processes, many different phenotypes from the same genotype can arise. In this case, each different result can be indentified with a phenotype seed. So, given specific initial conditions, a single specimen can be identified only by two integers: genotype and phenotype seeds.
- **rhythmic grid**: Data structure that characterizes a rhythmic pattern by specifying length, talea and other features.
- **harmonic grid**: Data structure that characterizes a harmony by specifying tonal center, pitch class set and other features.
- **talea**: Array of values that represents a sequence of relative durations (updated concept taken from ancient music).
- **prolatio**: Hierarchical time grid structure.
- **quantization**: Adjustment of relatives durations of a talea to a prolatio.

---------
# Anatomy of a genotype function

## Function name
As a convenient convention to improve the understanding of the function tree, **genotype functions** are named beginning with the type identifier, a letter that identifies their type of output (see [function types for genotypes](#function-types-for-genotypes)).

## Input arguments
All genotype functions, except leaf functions, expect arguments received from another genotype function. The input arguments can only come from one of the predefined types of genotype function.

The names of the input arguments are of free choice.

## Output data structure 
To enable automatic chaining of functions, all functions inside a genotype share the same output data structure. This output data is returned within an array according to the following order of elements:

| index | variable name  | data type                      | description
| ----- | -------------- | ------------------------------ | -----------
| 0     | **funcType**   | string                         | Function type according to its output (see [reference](#function-types-for-genotypes)).
| 1     | **decGen**  | string                         | Decoded genotype excerpt. Functional expression of the genotype branch computed until that node, including the function itself.
| 2     | **encPhen** | array of floats &isinv; [0, 1] | Encoded phenotype excerpt. Transformation of the input data made with the compositional procedures of the function itself.
| 3     | **phenLength** | integer                        | Number of phenotype events generated so far. Useful for subsequent functions to avoid overly large processes.
| 4     | **tempo**      | float                          | Tempo of the phenotype. The float uses the [durationF](#durationf-d) format to indicate the duration of a quarter note. Default value: 0.6 (equivalent to &#9833;= 60)
| 5     | **rhythm**     | dictionary                     | Rhythmic grid characterized with this [data structure](#rhythmic-grid).
| 6     | **harmony**    | dictionary                     | Harmonic grid characterized with this [data structure](#harmonic-grid).

First five elements are compulsory for every function inside a genotype. Informations about rhythm and harmony can be useful for subsequent functions, but they are optional. 

Variable names inside each genotype function are not compulsory, but is highly recommended to maintain the same nomenclature to improve code readability and reusability.

More fields can be added if needed, but always after the first seven preset items.

The **decoded genotype** is created only when the specimen is sent to another music software.

## Genotype function template

```
var <iFunctionName> = function (argument1, argument2, ..., argumentN) {
    ////
        < check block > // checks that the execution of the function will produce a phenotype that satisfies the constraints of the predetermined initial conditions
    ////
    var funcType = "<functionType>"; // describes the type of the function itself
    var encPhen = []; // this array will contain the produced encoded phenotype
    ////
        < core block > // executes the musical transformations of the function, writing the results in the variable encPhenOut, and calculating at the end of the process the updated values of phenLength, tempo, rhythm and harmony.
    ////
    var decGen = "<iFunctionName>(" + argument1[1] + "," + + argument2[1] + "," + ... argumentN[1] + ")"; // creates a string as a self-reference of the functional expression that has been evaluated.
    return writeSubexprReturnData(funcType, decGen, encPhen, phenLength, tempo, rhythm, harmony);
};
```

The last line uses the auxiliary function **writeSubexprReturnData**, which stores all the subexpressions generated during the evaluation of the function tree so far, and returns the array with the [output data structure](#output-data-structure) described above.

---------
# Function libraries
A GenoMus Function Library is a JSON file that contains all available functions for genotype generation of a specific species. The concept of species is crucial, because each species is determined by the parameter structure of a basic sonic event. The functional arquitecture depends on this specification. Specimens belonging to different species cannot be mixed without some kind of ad hoc adaptation. Consequently, an independent library must be created for each new species. The default species of GenoMus, called *piano*, uses this parameters structure for each basic event:

[*\<duration\>*, *\<pitch\>*, *\<articulation\>*, *\<intensity\>*]
 

A GenoMus Function Library contains these blocks:
- **"metadata"**: 
  - **"species"**: name of the species.   
  - **"parametersStructure"**: basic event parameter structure. 
  - **"user"**: username
  - **"version"**: version number of the catalogue.
  - **"updated"**: date of last update.
  - ...
- **"outputType"**: all functions for genotype generation, grouped according to their output type.
- **"functionIndex"**: all functions for genotype generation, enumerated by their order of inclusion, along with their encoded function index.

## Indexing a function in a GenoMus Function Library
Functions are listed following this format:
```
"outputType": {
    "<functionType>": {
        "<functionName>": {
            "arguments": ["<functionType>", "<functionType>", ...],
            "description": "String describing what the function does.",
        "metadata": {
            "date": (date of creation, in compressed style),
            "creator": "<username>",
            ... (optional information if needed.)
        },
        ...
    },
    "<functionType>": {
    ...
}
```
- _**functionName**_ should use the corresponding prefix to help a human to know its output type
- The _**description**_ and _**metadata**_ fields are optional, but very helpful to understand quicky the processes in a genotype, and to add further informations and documentation about the function or the programmer

Furthermore, each function must be included in the list of function index numbers:
```
"functionIndex": {
    1: {
        "functionName": 0.618034
    },
    2: {
        "functionName": 0.236068
    },
    ...
}
```
The integer index identifies the function. The float is the *encoded function index*. It is a number to map the function within the normalized interval [0, 1]. Encoded genotypes use this float to map all functions optimizing the maximal distance among functions into the interval. That's a critical issue for the automatic characterization of genotypes by machine learning techniques. 

Index numbers must correspond to only one function. To maintain the consistency of the library, an indexed function should not change its index numbers.

---------
## Encoded function index generation
Encoded function indexes are generated using a golden angle iteration mapped on the [0, 1] interval using this formula:

<img src="formulae/encoded_function_index.svg" width="180">

where *&#981;* is the golden ratio, _**f<sub>e</sub>**_ is the index to identify the function in encoded genotypes and _**f<sub>d</sub>**_ is the correspondent decoded index, which is asigned incrementally in the catalogue. Encoded index numbers are rounded to have only six digits after the decimal point. Using this truncated format there are 514263 different indexes available until a recurrence occurs.

This graph shows the distribution of the first 100 encoded function indexes:

<img src="formulae/encoded_function_index_graph.png" width="750">

From the *functionIndex* dictionary, an inverse dictionary is automatically created by rearranging the functions according to their ascending encoded index, following this format:

```
"encodedFunctionIndexes": {
    "0.236068": "functionNameX",
    "0.618034": "functionNameY",
    ...
}
```

This works as a useful lookup table for some automatic and manual processes.

---------
# Genotype function types
Genotype functions are classified by their output data. 

---------
## Used function type identifiers
~~**a** **b** **c** **d** **e** **f** **g** **h** **i**~~ j k ~~**l** **m** **n** **o** **p**~~ q ~~**r** **s** **t** **u** **v** **w** **x**~~ y z

---------
## Main structures

| *function type* | *identifier* | *output*
| --------------- | ------------ | --------
| **scoreF**      | **s**        | score
| **voiceF**      | **v**        | voice
| **eventF**      | **e**        | event
| **listF**       | **l**        | list of normalized floats &isinv; [0, 1]
| **paramF**      | **p**        | normalized parameter
| **leaf**        | -            | norm. parameter or specific format parameter

The **leaf** type is a flag for terminal nodes. This is not really a type of function, but a label to indicate that a new function will not be called.

---------
## Human-readable leaf parameters
Function types created to improve manual handling of decoded genotypes. These functions can replace a **paramF** functions in a leaf position of function tree.

| *function type*   | *identifier* | *output*
| ----------------- | ------------ | --------
| **notevalueF**    | **n**        | normalized duration from usual number used for note values (1 = whole note)
| **durationF**     | **d**        | normalized duration from duration in seconds
| **midipitchF**    | **m**        | normalized pitch from standard MIDI pitch
| **frequencyF**    | **f**        | normalized pitch from frequency in Hz
| **articulationF** | **a**        | normalized relative articulation (1 is whole duration of the note, 2 is double duration)
| **durationF**     | **d**        | normalized duration from time in seconds
| **intensityF**    | **i**        | normalized intensity from standard MIDI velocity
| **quantizedF**    | **q**        | normalized value from integer &isinv; [-36, 36]

---------
## Human-readable lists

These functions receive a list of human-readable leaf parameters and return a normalized list, which can be seamlessly integrated into automatic processes.

| *function type*    | *identifier* | *output*
| ------------------ | ------------ | --------
| **lnotevalueF**    | **ln**       | list of normalized durations from list of note values (1 = whole note)
| **ldurationF**     | **ld**       | list of normalized durations from list of duration in seconds
| **lmidipitchF**    | **lm**       | list of normalized pitches from list of MIDI pitches
| **lfrequencyF**    | **lf**       | list of normalized pitches from frequencies in Hz
| **larticulationF** | **la**       | list of normalized relative articulations from list of relative articulations
| **lintensityF**    | **li**       | list of normalized intensities from MIDI velocities
| **lquantizedF**    | **lq**       | list of normalized values from list of integer &isinv; [-36, 36]

---------
## Domain-specific formats
Function types created to manage specific types of data (some of them are still purely theoretical)

| *function type* | *identifier* | *output*
| --------------- | ------------ | --------
| **operationF**  | **o**        | result of an arithmetic operation, useful to construct recursive mathematical expressions inside a genotype
| **binaryF**     | **b**        | boolean value (only 0 or 1)
| **rhythmF**     | **r**        | rhythmic pattern (nested array of floats &isinv; [0, 1])
| **harmonyF**    | **h**        | pitch class sequence, useful for specifying scales, modes, chords, pitch aggregates, harmonic series, etc.
| **catalogueF**   | **c**       | pointer to an external genotype from a specimen catalogue (to be used with functions referencing external data)
| **genotypeF**   | **g**        | raw encoded genotype (array of floats &isinv; [0, 1])
| **txtF**        | **t**        | string
| **waveF**       | **w**        | encoded path to read data from an stored audio file

---------
## Manual manipulation of genotypes
Functions to be used typing manually on the genotypes to get a more controlled evolution.

| *function type* | *identifier* | *output* |
| --------------- | ------------ | --------
| **userF**       | **u**        | these functions perform very different manipulations on part of a genotype, acting as a metalevel of functional control

User functions use uppercase letters to be easily found during manual editing processes. Some examples of this type:
- **uEVOLVE** (*expr*) - contains the part of a genotype to be transformed, freezing the rest
- **uFREEZE** (*expr*) - block a part of a genotype to be preserved from transformations
- **uFLATTEN** (*expr*) - render part of a genotype into a simple declarative score/voice/event (phenotype)

---------
# Parameters mapping
A GenoMus function tree expects generic parameters (floats &isinv; [0, 1]) as leaves, regardless arguments' domain. When computing a phenotype, these numbers must be mapped to correct ranges and scales to represent duration, pitch, etc.

Human-readable function types use specific user-friendly formats for each argument. These non generic parameters are first mapped to a normalized interval [0, 1] to be later evaluated and encoded as stardard normalized paramenters.

In general, these maps are not linear (straight line maps). For each type of parameter, a Gaussian approach is employed, trying to cover a wide range of values for each category, but at the same time modeling the conversion so that central values (specially the range [0.25, 0.75]) map to the musical values that appear more frequently.

Since each species could require new domain-specific parameters, for each new parameter a mapping similar to those presented below must be defined.

Parameters mapping is used in several contexts:
- **To display decoded genotypes** in a more human-readable way, converting normalized values to domain-specific ranges when possible.
- **To encode genotypes**, converting arguments entered manually using user-friendly function types to normalized values.
- **To render phenotypes** (scores or soundfiles), converting normalized values to domain-specific ranges.

--------
## Duration

### **notevalueF** (n) 

Input can be the usual ratio for each note value or a float. This value is relative, and its actual duration will depend on the current tempo mark. 

Conversion formulae: normalized parameter _**p**_ to note value ratio _**v**_ and inverse ([graph](https://www.desmos.com/calculator/ysm8zt5rbl)):

<img src="formulae/norm2notevalue.svg" width="100">
<img src="formulae/notevalue2norm.svg" width="175">
<img src="formulae/norm2notevalue_graph.png" width="250">

| [0, 1] | *v* (float)  | *v* (ratio) | notation (Am) / (Br)                    | seconds if &#9833;= 60 
| ------ | ------------ | ----------- | --------------------------------------- | ---------------------- 
| 0      | 0.00390625   | 1/256       | 256th note / demisemihemidemisemiquaver | 0.015625               
| 0.1    | 0.0078125    | 1/128       | 128th note / semihemidemisemiquaver     | 0.03125                
| 0.2    | 0.015625     | 1/64        | 64th note / hemidemisemiquaver          | 0.0625                 
| 0.3    | 0.03125      | 1/32        | 32th note / demisemiquaver              | 0.125                  
| 0.4    | 0.0625       | 1/16        | 16th note / semiquaver                  | 0.25                   
| 0.5    | 0.125        | 1/8         | 8th note / quaver                       | 0.5                    
| 0.6    | 0.25         | 1/4         | quarter note / crotchet                 | 1                      
| 0.7    | 0.5          | 1/2         | half note / minim                       | 2                      
| 0.8    | 1            | 1           | whole note / semibreve                  | 4                      
| 0.9    | 2            | 2           | double note / breve                     | 8                      
| 1.0    | 4            | 4           | quadruple note / longa                  | 16                     

#### Reference table for main noteValues



<img src="figures/all_noteValues.svg" width="900">

<sub>The numbers below the figures indicate note values as part of triplets and quintuplets.</sub>

### **durationF** (d) 

Conversion formulae: normalized parameter _**p**_ to seconds _**s**_ and inverse ([graph](https://www.desmos.com/calculator/pn1nbunlcz)):

<img src="formulae/norm2duration.svg" width="100">
<img src="formulae/duration2norm.svg" width="175">
<img src="formulae/norm2seconds_graph.png" width="250">

| [0, 1] |  dur. (s)   
| ------ | -------- 
| 0      | 0.015625 
| 0.1    | 0.03125  
| 0.2    | 0.0625   
| 0.3    | 0.125    
| 0.4    | 0.25     
| 0.5    | 0.5      
| 0.6    | 1        
| 0.7    | 2        
| 0.8    | 4        
| 0.9    | 8        
| 1.0    | 16       

--------
## Pitch
### **midipitchF** (m)

Linear conversion keeping encoded normalized data easily readable.

Conversion formulae: normalized parameter _**p**_ to MIDI pitch _**m**_ and inverse ([graph](https://www.desmos.com/calculator/atupolxw6d)):

<img src="formulae/norm2midipitch.svg" width="125">
<img src="formulae/midipitch2norm.svg" width="100">
<img src="formulae/norm2midipitch_graph.png" width="250">s

| [0, 1]  |  MIDI pitch   | Notation
| ------  | ------------- | ----------
| 0       | 12            | C<sub>0</sub>
| 0.09    | 21            | A<sub>0</sub> <sub>(lowest piano key)</sub>
| 0.12    | 24            | C<sub>1</sub>
| 0.24    | 36            | C<sub>2</sub>
| 0.36    | 48            | C<sub>3</sub>
| 0.48    | 60            | C<sub>4</sub> <sub>(middle C)</sub>
| 0.5     | 62            | D<sub>4</sub> <sub>(central note between flats and sharps)</sub>
| 0.60    | 72            | C<sub>5</sub>
| 0.72    | 84            | C<sub>6</sub>
| 0.84    | 96            | C<sub>7</sub>
| 0.96    | 108           | C<sub>8</sub> <sub>(highest piano key)</sub>
| 1.0     | 112           | E<sub>8</sub>
 
### **frequencyF** (f)

Conversion formulae: normalized parameter _**p**_ to frequency in hertz _**h**_ and inverse ([graph](https://www.desmos.com/calculator/ixocptnpba)):

<img src="formulae/norm2hertz.svg" width="101">
<img src="formulae/hertz2norm.svg" width="110">
<img src="formulae/norm2hertz_graph.png" width="250">

| [0, 1]   |  Hz      
| -------- | -------- 
| 0        | 0.000001 
| 0.1      | 2        
| 0.2      | 32       
| 0.3      | 162 
| 0.385129 | 440 
| 0.4      | 512      
| 0.5      | 1250     
| 0.6      | 2592     
| 0.7      | 4802     
| 0.8      | 8192     
| 0.9      | 13122    
| 1.0      | 20000    

--------
## Articulation

Articulation can be used in two modes:

- absolute articulation: The duration of the sound is measured in seconds, and is independent of tempo and event duration. The **durationF** function type is used for this articulation. 
- relative articulation: the duration of the sound is a ratio of the event duration. 1 means that the sound will last the whole duration, 0.5 is the half of the event duration, and so on. For this proportional articulation the function type **articulationF** must be employed.

### **articulationF** (a)
Conversion formulae: normalized parameter _**p**_ to relative articulation _**a**_, as a proportion of event duration ([graph](https://www.desmos.com/calculator/i5jiq4k9ah)):

<img src="formulae/norm2articulation.svg" width="63">
<img src="formulae/articulation2norm.svg" width="82">
<img src="formulae/norm2articulation_graph.png" width="250">

| [0, 1]   |  proportion of event duration | notation
| -------- | ----------------------------- | --------
| 0        | 0                             | silence
| 0.1      | 0.005739                      |
| 0.2      | 0.037768                      | *staccatissimo*
| 0.3      | 0.113708                      |
| 0.4      | 0.248547                      | *staccato*
| 0.5      | 0.455866                      |    
| 0.51729  | 0.5                           | *non legato*
| 0.6      | 0.748296                      |
| 0.66     | 0.969596                      |
| 0.667539 | 1                             | *legato*
| 0.7      | 1.137769                      |
| 0.8      | 1.635658                      | *legatissimo*
| 0.861429 | 2                             |
| 0.9      | 2.252888                      |
| 1.0      | 3                             | *lasciare vibrare*

--------
## Intensity
### **intensityF** (i)
Conversion formulae: normalized parameter _**p**_ to intensity _**i**_ in standard MIDI velocity  and inverse ([graph](https://www.desmos.com/calculator/cisndyw3gs)):

<img src="formulae/norm2intensity.svg" width="72">
<img src="formulae/intensity2norm.svg" width="67">
<img src="formulae/norm2intensity_graph.png" width="250">

| [0, 1] |  MIDI velocity      | notation
| ------ | ------------------- | --------
| 0      | 0                   |  silence
| 0.06   | 7.62                | **_pppp_**
| 0.15   | 19.05               | **_ppp_**
| 0.25   | 31.75               | **_pp_**
| 0.33   | 41.91               | **_p_**
| 0.4    | 50.8                | **_mp_**
| 0.5    | 63.5                | **_mf_**
| 0.66   | 83.82               | **_f_**
| 0.75   | 95.25               | **_ff_**
| 0.9    | 114.3               | **_fff_**
| 1.0    | 127                 | *tutta forza*

---------
## Quantized steps
### **quantizedF** (q)

This manual format is useful for different contexts where integer numbers can be much more readable. A possible application may be, for instance, to write a sequence of melodic intervals using a diatonic scale as the step basis.  
Conversion formulae: normalized parameter _**p**_ to quantized steps _**q**_ ([graph](https://www.desmos.com/calculator/3vy4gwjxcu)):

<img src="formulae/norm2quantized.svg" width="440">

The inversion is made with a lookup table.

<img src="formulae/norm2quantized_graph.png" width="450">

| [0, 1] |  integer steps      
| ------ | -------------------
| 0      | -36                   
| 0.0005 | -35                
| 0.001  | -34               
| 0.003  | -33               
| 0.006  | -32               
| 0.008  | -31                
| 0.01   | -30                
| 0.015  | -29               
| 0.02   | -28               
| 0.025  | -27               
| 0.03   | -26                 
| 0.04   | -25                 
| 0.045  | -24                 
| 0.05   | -23                 
| 0.06   | -22                 
| 0.07   | -21
| 0.08   | -20                 
| 0.09   | -19               
| 0.1    | -18               
| 0.11   | -17               
| 0.12   | -16                 
| 0.14   | -15                 
| 0.15   | -14                 
| 0.16   | -13                 
| 0.18   | -12                 
| 0.2    | -11
| 0.21   | -10
| 0.23   | -9               
| 0.25   | -8               
| 0.27   | -7               
| 0.3    | -6                 
| 0.32   | -5                 
| 0.33   | -4                 
| 0.36   | -3                 
| 0.4    | -2                 
| 0.45   | -1
| 0.5    | 0
| 0.55   | 1
| 0.6    | 2
| 0.64   | 3
| 0.67   | 4
| 0.68   | 5
| 0.7    | 6
| 0.73   | 7
| 0.75   | 8
| 0.77   | 9
| 0.79   | 10
| 0.8    | 11
| 0.82   | 12
| 0.84   | 13
| 0.85   | 14
| 0.86   | 15
| 0.88   | 16
| 0.89   | 17
| 0.9    | 18
| 0.91   | 19
| 0.92   | 20
| 0.93   | 21
| 0.94   | 22
| 0.95   | 23
| 0.955  | 24
| 0.96   | 25
| 0.97   | 26
| 0.975  | 27
| 0.98   | 28
| 0.985  | 29
| 0.99   | 30
| 0.992  | 31
| 0.994  | 32
| 0.997  | 33
| 0.999  | 34
| 0.9995 | 35
| 1      | 36


---------
## rhythmF

The output of a **rhythmF** function is an abstract time grid determined by a nested array with relative durations. This grid is called **prolatio**, and is used to quantize the values of a rhythmic pattern. 

The values inside a prolatio array are not absolute durations, but only proportions among themselves. For example, *prolationes* `[3,1,4]` and `[0.63,0.21,0.84]` are equivalent. A prolatio need a reference value to be rendered as a series of durations. Application of this prolatio to a half note (1/2) as total length:

<img src="figures/prolatio_basic.svg" width="117">

Each value of a prolatio can in turn be subdivided into another prolatio using a subarray in the next position. The last value in this prolatio can be subdivided in this way:

`[3,1,4,[1,1,1,1,1]]`, with this result:

<img src="figures/prolatio_basic_2.svg" width="170">

Obviously, each subarray must have at least two values to produce a subdivision at the next depth level of the prolatio. A prolatio with the scheme `[a,[d,e],b,c,[f,g,[i,j],h]]` has three level of subdivisions of the duration set by the variable **totalValue**:

<img src="figures/prolatio_tree.svg" width="140">

Prolationes can be arbitrarily complex. A simple array like `[1,[2,3],1,[1,[1,4],4,2],1,[1,1,[3,4,4]]]` produces nested tuplets (with a whole note as total duration):

<img src="figures/prolatio_complex.svg" width="476">

If more levels of subdivision are required but not specified, simple binary subdivisions are made by default.

These examples use integers for simplicity, but the output of a rhythmF function is always a nested array including only floats &isinv; [0, 1]. For instance, the last example of prolatio would be rescaled so that the maximum value was 1, returning this normalized nested array:

`[0.25,[0.5,0.75],0.25,[0.25,[0.25,1],1,0.5],0.25,[0.25,0.25,[0.75,1,1]]]`

All the functions working with a prolatio perform a normalization before processing or returning data, so simple proportions of integers as in the previous examples can be manually introduced in a decoded genotype. 

---------
## harmonyF

The output of a **harmonyF** function is a sequence of floats within interval \[0, 12\). 

This array is not a pitch class set but a pitch class sequence, because in some contexts the order determines certain algorithmic operations. However, this format can also serve as a pitch class set when needed.

Numbers represent pitches with the usual pitch class notation (0 = C, 1 = C&#9839;, etc), but in many occasions these pitches are transposed. So it is better to contemplate this sequence as an abstract series of intervals, in which C is used as baseline by default. Values can include a decimal part to denotate microtonal intervals.



---------
# Characterization of underlying musical patterns

During the evaluation of a genotype function tree, functions complement output data with auxiliary information concerning underlying musical patterns regarding to rhythm and harmony. These data are useful for the analysis and automatic characterization of genotypes, and for certain functions that use this data directly for the evaluation of phenotypes.

Other characteristics beyond rhythm and harmony can be added according to the needs and the event format of each species.

---------
## Rhythmic grid

A rhythmic pattern can be expressed as a dictionary containing informations to be used by other functions to map durations. These data represent a rhythmic pattern and its interrelations with a time grid and with the level of general quantization. Using this dictionary, certain functions adjust their values to get different rhythmic structures and analytical information.

A **rhythmic grid** is coded into an array following this data structure:

| index | feature          | data format          | description
| ----- | ---------------- | -------------------- | ----------- 
| 0     | **totalValue**   | notevalueF           | pattern length
| 1     | **talea**        | rhythmF              | rhythmic pattern (regardless of central value)
| 2     | **prolatio**     | rhythmF              | successive levels of divisions in the time grid to which the rhythmic values will be adjusted
| 3     | **quantization** | float &isinv; [0, 1] | degree of adjustment to quantization scheme (higher means more rhythmic complexity)

---------
### totalValue

The duration of reference to perform all rhythmic pattern transformations is determined by **totalValue**, formatted according to the mapping of [**notevalueF**](#notevaluef-n) functions.

---------
### talea

A **talea** is a rhythmic pattern, a sequence of numbers representing relative durations. Its format can be a simple float array (no normalization is required), or can be derived from a nested array as output of a [**rhythmF**](#rhythmf) function.

The order of values in a **talea** matters, because the position within the sequence determines the priority of taken values for low degrees of quantization (the first, the most important).

---------
### prolatio

A **prolatio** is a nested time grid used to adjust the raw values received from a talea. A prolatio follow the format of [**rhythmF**](#rhythmf) functions output. 

---------
### quantization

| quantization | result
| ------------ | ------
| 0            | all values are quantized to the totalValue duration (all events are played simultaneously, prolatio is not taken into account)
| (0, 1)       | gradual quantization using progressive levels of prolatio depth
| 1            | no quantization applied, values mapped with full rhythmic resolution (prolatio is not taken into account)

---------
### Example of rhythmic motives

The following tables show how increasing degrees of quantization of this rhythmic grid: 

```
{
    "totalValue": 1,
    "talea": [0.1,0.1,0.4,0.8,0.4,0.5],
    "prolatio": [2,[1,[1,1],1,[1,1],1],4,1,[2,[3,1],1,1],1,[2,1]],
    "quantization": <float within interval [0, 1]>
}
```

First of all, the talea `[0.1,0.1,0.4,0.8,0.4,0.5]` is rescaled to `[0.044,0.044,0.174,0.348,0.174,0.216]` Now, the sum of all the numbers in the sequence is 1. The relative durations of this talea can be visualized as horizontal segments: 

<img src="figures/talea.svg" width="500">

The next step is to determine quantization thresholds based on the prolatio depth levels. In this example, the prolatio has three levels that are mapped to the intervals (0, &#8531;], (&#8531;, &#8532;] and (&#8532;, 1).

| **quantization** = 0                               | totalValue = 1 <sub>(whole note)</sub>
| -------------------------------------------------- | -----
| **raw talea** (rescaled)                           | `[0.044,0.044,0.174,0.348,0.174,0.216]`
| **prolatio** depth = 0 (code)                      | Prolatio is not used, all values converge to **totalValue**
| **prolatio** depth = 0 (score)                     | <img src="figures/prolatio_ex0.svg" width="78">
| **talea to prolatio quantization** (visualization) | <img src="figures/q0.svg" width="500">
| **quantized talea**                                | `[1]`
| **final result** (score)                           | <img src="figures/prolatio_ex0.svg" width="78">

| 0 < **quantization** &#8804; &#8531;               | totalValue = 1 <sub>(whole note)</sub>
| -------------------------------------------------- | -----
| **raw talea** (rescaled)                           | `[0.044,0.044,0.174,0.348,0.174,0.216]`
| **prolatio** depth = 1 (code)                      | `[2,4,1,1]`
| **prolatio** depth = 1 (score)                     | <img src="figures/prolatio_ex1.svg" width="130">
| **talea to prolatio quantization** (visualization) | <img src="figures/q1-3.svg" width="500">
| **quantized talea**                                | `[0.25,0.5,0.25]`
| **final result** (score)                           | <img src="figures/final_quant_ex1.svg" width="108">

| &#8531; < **quantization** &#8804; &#8532;         | totalValue = 1 <sub>(whole note)</sub>
| -------------------------------------------------- | -----
| **raw talea** (rescaled)                           | `[0.044,0.044,0.174,0.348,0.174,0.216]`
| **prolatio** depth = 2 (code)                      | `[2,[1,1,1],4,1,[2,1,1],1,[2,1]]`
| **prolatio** depth = 2 (score)                     | <img src="figures/prolatio_ex2.svg" width="270">
| **talea to prolatio quantization** (visualization) | <img src="figures/q2-3.svg" width="500">
| **quantized talea**                                | `[0.083, 0.167, 0.5, 0.062, 0.188]`
| **final result** (score)                           | <img src="figures/final_quant_ex2.svg" width="169">

| &#8532; < **quantization** < 1                     | totalValue = 1 <sub>(whole note)</sub>
| -------------------------------------------------- | -----
| **raw talea** (rescaled)                           | `[0.044,0.044,0.174,0.348,0.174,0.216]`
| **prolatio** depth = 3 (code)                      | `[2,[1,[1,1],1,[1,1],1],4,1,[2,[3,1],1,1],1,[2,1]]`
| **prolatio** depth = 3 (score)                     | <img src="figures/prolatio_ex3.svg" width="400">
| **talea to prolatio quantization** (visualization) | <img src="figures/q3-3.svg" width="500">
| **quantized talea**                                | `[0.042, 0.042, 0.168, 0.5, 0.048, 0.2]`
| **final result** (score)                           | <img src="figures/final_quant_ex3.svg" width="280">

| **quantization** = 1                               | totalValue = 1 <sub>(whole note)</sub>
| -------------------------------------------------- | -----
| **raw talea** (rescaled)                           | `[0.044,0.044,0.174,0.348,0.174,0.216]`
| **prolatio**                                       | Prolatio is not needed because there is no quantization
| **talea to prolatio** (visualization)              | <img src="figures/q1.svg" width="500">
| **quantized talea** (no quantization is done)      | `[0.044,0.044,0.174,0.348,0.174,0.216]`
| **final result** (score)                           | <img src="figures/prolatio_Q1-0.svg" width="230">

It is important to note that some of the rendered values could be rests. Rest are produced when event atributes as articulation or intensity are set to 0. 

The final result of a rhythmic grid is a sequence of floats. Consequently, a processed rhythmic grid can be a talea for a new grid.

--------
## Harmonic grid

A harmony can be expressed as a dictionary containing informations to be used by other functions to map pitches. These data is a representation of a group of pitches (usually a chord) and its interrelations with a pitch class set (usually a mode) and with the level of general chromatism. Using this information, certain functions adjust their values to the grid of pitches that fits this harmony and extract analytical information.

A **harmonic grid** is coded into an array following this data structure:

| index | feature          | data format          | description
| ----- | ---------------- | -------------------- | ----------- 
| 0     | **root**         | midipitchF           | main reference pitch (usually a chord's root)
| 1     | **chord**        | harmonyF             | pitch class sequence with the harmony pitches (regardless of tonal center)
| 2     | **mode**         | harmonyF             | pitch class sequence (usually, a scale) containing the chord pitches using C (pitch class 0) as root 
| 3     | **chromaticism** | float &isinv; [0, 1] | tolerance to chromatic notes (higher means more chromatic results)

**chord** and **mode** are not a pitch class sets because order matters. The position within the pitch sequences determines the priority of each pitch for low degrees of chromaticism (the first, the most important). 

### chromaticism

Chromaticism is applied as a kind of pitch quantization. The raw pitch values of a melodic sequence is *rounded* to a series of pitch classes. The degree of **chromaticism** is denoted with a normalized value, which determines how complex is the sequence of eligible pitch classes.

This is the meaning of different values for chromaticism:

| chromaticism (*c*)        | result
| ----------------------- | ------
| 0 &#8804; *c* &#8804; 0.5 | only chord pitch classes are used, progressively incorporated as *c* is higher (0 &rarr; only 1 pitch class, 0.5 &rarr; all chord pitch classes)
| 0.5 < *c* &#8804; 0.8     | mode pitches classes are progressively integrated (0.500001 &rarr; only 1 new pitch class added, 0.8 &rarr; complete mode is employed)
| 0.8 < *c* &#8804; 1       | all remaining pitch classes of the chromatic scale are integrated

### Example of harmonic motives

Given this harmonic grid:

```
{
    "root": 0.68124,
    "chord": [1,0,5,8,3],
    "mode": [0,3,1,5,8,6,11,10],
    "chromaticism": <float within interval [0, 1]>
}
```

The algorithm follow these steps:
1. Set the tonal center with **root**. The value `0.68124` correspond to the pitch A&#9837;, applying this [conversion](#midipitchf-m). 
2. Transpose pitch classes of **chord** and **mode** from C to G&#9839; (or A&#9837;) as root, keeping the same order: 

`[11,0,5,8,3]` &rarr; `[7,8,1,4,11]`:

<img src="figures/chord.svg" width="261"> 

`[0,3,1,5,8,6,11,10]` &rarr; `[8,11,9,1,4,2,7,6]`

<img src="figures/mode.svg" width="348"> 

3. Check the pitch classes of mode which are not part of chord and extract this ordered subsequence. In this case, the result is `[9,2,6]`.
4. Calculate the ranges of values corresponding to the increasing degrees of chromaticism, and transform input data accordingly.

The following tables show how increasing degrees of chromaticism affect to this grid, and the effect of applying it to a two-voices music excerpt (enharmonic differences are not relevant): 

| chromaticism (*c*) ranges of values | eligible pitch classes        | result
| ----------------------------------- | ----------------------------- | ----
| 0 &#8804; *c* < 0.1                 | `[7]` (monochordal)                         | <img src="figures/excerpt-chromat-0.svg" width="200"><a href="https://raw.githubusercontent.com/lopezmontes/GenoMus/master/specifications/mp3_examples/chromaticism-0.mp3?token=ABGBHAJUPGQWEILSIBWES4K5KUNFK"><img src="aux/speaker.svg" width="15"></a> 
| 0.1 &#8804; *c* < 0.2               | `[7,8]`                                     | <img src="figures/excerpt-chromat-0-1.svg" width="200"><a href="https://raw.githubusercontent.com/lopezmontes/GenoMus/master/specifications/mp3_examples/chromaticism-0-1.mp3?token=ABGBHAIEADEUJMM627NGNM25KUMZO"><img src="aux/speaker.svg" width="15"></a>
| 0.2 &#8804; *c* < 0.3               | `[7,8,1]`                                   | <img src="figures/excerpt-chromat-0-2.svg" width="200"><a href="https://raw.githubusercontent.com/lopezmontes/GenoMus/master/specifications/mp3_examples/chromaticism-0-2.mp3?token=ABGBHAJLZGJQ2KT5FUHY24S5KUM3Y"><img src="aux/speaker.svg" width="15"></a>
| 0.3 &#8804; *c* < 0.4               | `[7,8,1,4]`                                 | <img src="figures/excerpt-chromat-0-3.svg" width="200"><a href="https://raw.githubusercontent.com/lopezmontes/GenoMus/master/specifications/mp3_examples/chromaticism-0-3.mp3?token=ABGBHAKRAXQ3WFJNTTICIYK5KUM7K"><img src="aux/speaker.svg" width="15"></a>
| 0.5 &#8804; *c* < 0.5               | `[7,8,1,4,11]` (complete chord)             | <img src="figures/excerpt-chromat-0-4.svg" width="200"><a href="https://raw.githubusercontent.com/lopezmontes/GenoMus/master/specifications/mp3_examples/chromaticism-0-4.mp3?token=ABGBHAI57KWEEAKD25YRWJK5KUNAK"><img src="aux/speaker.svg" width="15"></a>
| 0.5 &#8804; *c* < 0.6               | `[7,8,1,4,11,9]`                            | 
| 0.6 &#8804; *c* < 0.7               | `[7,8,1,4,11,9,2]`                          | 
| 0.7 &#8804; *c* < 0.8               | `[7,8,1,4,11,9,2,6]` (complete mode)        | <img src="figures/excerpt-chromat-0-5.svg" width="200"><a href="https://raw.githubusercontent.com/lopezmontes/GenoMus/master/specifications/mp3_examples/chromaticism-0-5.mp3?token=ABGBHAPNELFTBH5OAN33AZK5KUNCE"><img src="aux/speaker.svg" width="15"></a>
| 0.8 &#8804; *c* &#8804; 1           | `[0,1,2,3,4,5,6,7,8,9,10,11]` (all pitches) | <img src="figures/excerpt-chromat-1.svg" width="200"><a href="https://raw.githubusercontent.com/lopezmontes/GenoMus/master/specifications/mp3_examples/chromaticism-1.mp3?token=ABGBHANAGTJ4VJ2UMJQ5AOS5KUND4"><img src="aux/speaker.svg" width="15"></a>

---------
# Encoding-decoding genotypes

An encoded genotype is an unidimensional array of normalized values &isinv; [0, 1]. This encoded form is intended to be an abstract numeric equivalent to the decoded genotype. The purpose of encoding is to provide a representation of compositional procedures, suitable for different machine learning techniques such as evolutionary algorithms or neural networks.

---------
## Conversion table for genotypes

|  type                                | identifier | value                  | example encoded &#x21C6; decoded 
| ------------------------------------ | ---------- | ---------------------- | ------------------------------------
| leaf <sub>normalized parameter</sub> | 0          | parameter              | `[0, 0.3]` &#x21C6; `"0.3"` 
| leaf <sub>notevalueF</sub>           | 0.01       | normalized parameter   | `[0.01, 0.3]` &#x21C6; `"1/32"` 
| leaf <sub>durationF</sub>            | 0.02       | normalized parameter   | `[0.01, 0.3]` &#x21C6; `"0.125"` 
| leaf <sub>midipitchF</sub>           | 0.03       | normalized parameter   | `[0.01, 0.3]` &#x21C6; `"42"` 
| leaf <sub>frequencyF</sub>           | 0.04       | normalized parameter   | `[0.01, 0.3]` &#x21C6; `"162"` 
| leaf <sub>articulationF</sub>        | 0.05       | normalized parameter   | `[0.01, 0.3]` &#x21C6; `"0.113708"` 
| leaf <sub>intensityF</sub>           | 0.06       | normalized parameter   | `[0.01, 0.3]` &#x21C6; `"38.1"` 
| leaf <sub>quantizedF</sub>           | 0.07       | normalized parameter   | `[0.01, 0.3]` &#x21C6; `"-6"` 
| leaf <sub>*newtypeF*</sub>           | < 0.2      | normalized parameter   | `[0.01, 0.3]` &#x21C6; *normalized converted value* 
| ,                                    | 0.2        | -                      | `[0.2]` &#x21C6; `","` 
| \[                                   | 0.4        | -                      | `[0.4]` &#x21C6; `"\["` 
| \]                                   | 0.6        | -                      | `[0.6]` &#x21C6; `"\]"` 
| \)                                   | 0.8        | -                      | `[0.8]` &#x21C6; `"\)"`
| function name + \(                   | 1          | encoded function index | `[1, 0.61803]` &#x21C6; `"functionName("`

---------
## Examples
### Minimal genotype
`"s(v(e(p(0.5),p(0.5),p(0.5),p(0.5))))"`

&#x21C5;

`[1, 0.618034, 1, 0.236068, 1, 0.854102, 1, 0.472136, 0, 0.5, 0.8, 0.2, 1, 0.472136, 0, 0.5, 0.8, 0.2, 1, 0.472136, 0, 0.5, 0.8, 0.2, 1, 0.472136, 0, 0.5, 0.8, 0.8, 0.8, 0.8]`

Visualization of this encoded genotype as a matrix of grayscale colors:

<img src="figures/example_1_visualization.png" width="500">

Phenotype:

<img src="figures/ex1_score.svg" width="57">


---------
### Minimal genotype with human-readable leaf parameters
`"s(v(e(n(1/16),m(69),a(0.4),i(84))))"`

&#x21C5;

`[1, 0.618034, 1, 0.236068, 1, 0.854102, 1, 0.09017, 0.01, 0.4, 0.8, 0.2, 1, 0.708204, 0.03, 0.57, 0.8, 0.2, 1, 0.326238, 0.05, 0.248547, 0.8, 0.2, 1, 0.944272, 0.06, 0,661417, 0.8, 0.8, 0.8, 0.8]`

This table shows the encoding/decoding of lexical tokens in this example:

| decoded | encoded
| ------- | -------
| `s(`    | `[1, 0.618034]`
| `v(`    | `[1, 0.236068]`
| `c(`    | `[1, 0.854102]`
| `n(`    | `[1, 0.09017]`
| `1/16`  | `[0.01, 0.4]`
| `)`     | `[0.8]`
| `,`     | `[0.2]`
| `m(`    | `[1, 0.708204]`
| `69`    | `[0.03, 0.57]`
| `a(`    | `[1, 0.326238]`
| `0.4`   | `[0.05, 0.248547]`
| `i(`    | `[1, 0.944272]`
| `80`    | `[0.06, 0,629921]`

Visualization:

<img src="figures/example_2_visualization.png" width="500">

Phenotype:

<img src="figures/ex2_score.svg" width="57">

---------
### List encoding
`"s(v(eMotif(ln([1/2,1/4,1/2,1/4]),lm([63,67,63,58]),a(1),i(42))))"`

&#x21C5;

`[1, 0.618034, 1, 0.236068, 1, 0.304952, 1, 0.652476, 0.4, 0.01, 0.7, 0.2, 0.01, 0.6, 0.2, 0.01, 0.7, 0.2, 0.01, 0.6, 0.6, 0.8, 1, 0.888544, 0.4, 0.03, 0.51, 0.2, 0.03, 0.55, 0.2, 0.03, 0.51, 0.2, 0.03, 0.46, 0.6, 0.8, 0.2, 1, 0.326238, 0.05, 0.667539, 1, 0.944272, 0.06, 0,330709, 0.8, 0.8, 0.8, 0.8]` 

The lists in this genotype have encoded as follows:

| decoded | encoded
| ------------------- | -------
| `[1/2,1/4,1/2,1/4]` | `[0.4, 0.01, 0.7, 0.2, 0.01, 0.6, 0.2, 0.01, 0.7, 0.2, 0.01, 0.6, 0.6]`
| `[63,67,63,58]`     | `[0.4, 0.03, 0.51, 0.2, 0.03, 0.55, 0.2, 0.03, 0.51, 0.2, 0.03, 0.46, 0.6]`

Visualization:

<img src="figures/example_3_visualization.png" width="500">

Phenotype:

<img src="figures/ex3_score.svg" width="140">

---------
### Complex example




---------
# Encoding-decoding phenotypes

The format of an encoded phenotype is formally identical to an encoded genotype: both are a sequence of normalized floats whithin interval [0, 1]. As a consequence, encoded genotypes and phenotypes can be seen mathematically as the same type of object: n-dimensional vectors of real numbers within the interval [0, 1]. Furthermore, the evaluation of genotypes can be understood as a map that relates musical procedures to musical scores. This map is non-injective: different genotypes can generate the same phenotype, since diverse compositional processes can lead to the same result. At the same time, if the phenotype seed is changed, a genotype can generate many different phenotypes.

---------
## Encoded phenotype structure

- All phenotypes have the same hierarchical structure: events within a voice, and voices within a score. 
- Event data is listed as normalized values. Voices and scores are notated using numbers as flags: `1` and `0` indicate beginnings and endings of these wrappers.
- A score can consist of several concatenated scores (especially when their number of voices is different). For this reason it is necessary to use flags to connect them.

| structure | encoding
| --------- | --------
| event     | `[<duration>, <numberOfPitches>, <pitch1>, <pitch2>, ..., <pitchN>, <articulation>, <intensity>]` 
| voice     | `[1, <encodedEvent1>, <encodedEvent2>, ..., <encodedEventN, 0]`
| score     | `[1, <encodedVoice1>, <encodedVoice2>, ..., <encodedVoiceN, 0]`

---------
# Genotype operations
## Creation
### Generating encoded genoypes from random values

Universal random search space. All vectors are a valid input.

n: 
### Self-references
## Mutation


---------
# Genotype substructures
## Genotype scaffolding

---------
## Function network

---------
## Leaves vector



---------
## Subexpressions

---------
 
# Initial conditions for generation of genotypes
## Constraints
## Eligible functions
## Mandatory functions
## Vector of desired musical characteristics
### Weighted measurement of Euclidean distance

--------- 
# Specimen data structure

All generated specimens are stored as temporary JSON files. Selected specimens are permanently saved as JSON files in the Specimen catalogue. These JSON files are created according to the following data structure:

- **"metadata"**: data to identify and classify the specimen within the catalogue.
  - **"specimenID"**: unique specimen identificator base on date of creation compressed as a unique number and usersname.
  - **"permalink**: permanent link to the JSON file of the specimen (only for selected specimens, not for temporary ones).
  - **"GenoMusVersion"**: GenoMus version that generated the specimen.
  - **"creationTimecode"**: creation date compressed as a unique number.
  - **"user"**: username.
  - **"species"**: event parameters structure defining the basic sonic events.
  - **"globalRating"**: average of aesthetic ratings obtained.
  - **"iterations"**: number of iterations of the algorithm until finding this specimen.
  - **"millisecondsElapsed"**: time elapsed until finding this specimen.
  - **"encGenotypeLength"**: length of the float array contaning the encoded genotype. 
  - **"encPhenotypeLength"**: length of the float array contaning the encoded phenotype.
  - **"decPhenotypeDuration"**: total duration of the generated piece in seconds.
  - **"depth"**: deepest level of ramification of the decoded genotype function tree.
  - **"totalFunctions**: total of different functions used.    
  - **"selfReference"**: measures reuse of internal substructures.  
- **"initialConditions"**: set of initial conditions to satisfy by the generative process.
  - **"eligibleFunctions"**: numeric array containing the eligible functions for genotype generation.
  - **"constraints"**: features required for a genotype to be acceptable for the generative algorithm.
    - **"maxGenotypeDepth"**
    - **"minPhenotypeLength"**
    - **"maxPhenotypeLength"**
    - **"maxIterations"**: maximal number of attempts before the generative process stops 
  - **"heuristics"**: weigthed list of desired features, similar to those in "automaticAnalysis" (see below).
  - **"genotypeSeed"**
  - **"phenotypeSeed"**
- **"encodedGenotype"**: array of floats &isinv; [0, 1].
- **"decodedGenotype"**: string containing the genotype function tree.
- **"expandedGenotype"**: string containing the decoded genotype, formatted with blanks and line breaks to clearly display the function tree.
- **"genotypeScaffolding"**: dictionary with pointers, length and output type of each substructure inside the encoded genotype.
- **"functionNetwork"**: dictionary with all used functions and their corresponding position in the encoded genotype.
- **"leavesVector"**: dictionary with all leaf values and their corresponding position in the encoded genotype. 
- **"subexpressions"**: list of all functional substructures within a genotype, enumerated by output type and order of appearance.
  - **"scoreF"**: subexpressions whose output is of type score.
  - **"voiceF"**: ...
  - **"eventF"**
  - **"listF"**
  - **"paramF"**
  - **"harmonyF"**
  - ...
- **"encodedPhenotype"**: array of floats &isinv; [0, 1].
- **"decodedPhenotype"**: phenotype converted to the desired formats (bach roll, bach score, lilypond, MusicXML, Csound, multimedia outputs, etc.)
- **"automaticAnalysis"**: automatic analysis of many different musical characteristics of the specimen, all expressed as an normalized value &isinv; [0, 1]. A higher number means more complexity.  
  - **"polyphony"**
  - **"rhythmicComplexity"**
  - **"chromatism"**
  - **"disonance"**
  - **"disjunctivity"**
  - **"modalChroma"**
  - **"tonalStability"**
  - **"tessituraDispersion"**
  - **"variability"**: measures how much use of repetition is made.
  - **"articulationHomogeneity"**
  - **"dynamicHomogeneity"**
- **"humanEvaluation"**: human evaluation of different musical, aesthetic and emotional aspects of the specimen. This item can store the assessment of many different users. 
  - **"aestheticValue"**
  - **"mood"**: emotional resonances, expressed as a vector of different axes (to be defined).
  - **"originality"**
  - **"predictability"**

---------
# Specimen catalogue
## Naming
## Classification
## Catalogue access


# Max user interface