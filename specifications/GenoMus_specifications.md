# GenoMus specifications

<img src="figures/GenoMus_figura_6-3.svg" width="160">

--------
## Table of Contents
- [GenoMus overview](#GenoMus-overview)
  - [Conceptual approach](#conceptual-approach)
  - [Flowchart](#flowchart) 
- [Definitions](#definitions)
- [Anatomy of a genotype function](#anatomy-of-a-genotype-function)
  - [Function name](#function-name)
  - [Input arguments](#input-argumentss)
  - [Output data structure](#output-data-structure)
  - [Genotype function template](#genotype-function-template)
- [Genotype function types](#genotype-function-types)
  - [Used function type identifiers](#used-function-type-identifiers)
  - [Main structures](#main-structures)
  - [Human-readable leaf parameters](#human-readable-leaf-parameters) 
  - [Human-readable lists](#human-readable-lists) 
  - [Domain-specific formats](#domain-specific-formats)
  - [Manual manipulation of genotypes](#manual-manipulation-of-genotypes)
- [Parameter mapping](#parameter-mapping)
  - [Duration](#duration)
    - [notevalueF (n)](#notevaluef-n)
      - [Reference table for main noteValues](#Reference-table-for-main-notevalues)
    - [durationF (d)](#durationf-d)
  - [Pitch](#pitch)
    - [midipitchF (m)](#midipitchf-m)
    - [frequencyF (f)](#frequencyf-f)
  - [Articulation](#articulation)
    - [articulationF (a)](#articulationf-a)
  - [Intensity](#intensity)
    - [intensityF (i)](#intensityf-i)
  - [Quantized steps](#quantized-steps)
    - [goldenintegerF (z)](#goldenintegerf-z)
    - [quantizedF (q)](#quantizedf-q)   
  - [rhythmF](#rhythmf)
  - [harmonyF](#harmonyf)
- [Characterization of underlying musical patterns](#characterization-of-underlying-musical-patterns)
  - [Rhythmic grid](#rhythmic-grid)
    - [totalValue](#totalvalue)
    - [talea](#talea)
    - [prolatio](#prolatio)
    - [quantization](#quantization)
    - [Example of rhythmic motives](#example-of-rhythmic-motives)
  - [Harmonic grid](#harmonic-grid)
    - [root, chord and mode](#root-chord-and-mode)
    - [chromaticism](#chromaticism)
    - [Example of harmonic grids](#example-of-harmonic-grids)
- [Function libraries](#function-libraries)  
  - [Function library data structure](#function-library-data-structure)
  - [Indexing a function in a GenoMus Function Library](#indexing-a-function-in-a-genomus-function-library)
  - [Encoded function index generation](#encoded-function-index-generation)
- [Core functions](#core-functions)
  - [Identity functions](#identity-functions)
  - [Internal autoreferences](#internal-autoreferences)
  - [External references](#external-references)
  - [Form](#form)
  - [Phrasing](#phrasing)
  - [Poliphony](#poliphony)
  - [Harmony](#harmony)
  - [Counterpoint](#counterpoint)
  - [Rhythm](#rhythm)
  - [Articulation](#articulation-1)
  - [Dynamics](#dynamics)
  - [Spectralism](#spectralism)
  - [Serialism](#serialism)
  - [Aleatoric processes](#aleatoric-processes)
  - [Algorithmic techniques](#algorithmic-techniques)
  - [List manipulation](#list-manipulation)
  - [Mathematical operations](#mathematical-operations)
  - [Manual operators of genotypes](#manual-operators-of-genotypes)
- [Encoding-decoding genotypes](#encoding-decoding-genotypes)
  - [Conversion table for genotypes](#conversion-table-for-genotypes)
  - [Formatting decoded genotypes](#formatting-decoded-genotypes)
- [Encoding-decoding phenotypes](#encoding-decoding-phenotypes)
- [Examples of specimens](#examples-of-specimens)
  - [Minimal specimen](#minimal-specimen)
  - [Minimal specimen with human-readable leaf parameters](#minimal-specimen-with-human-readable-leaf-parameters)
  - [Voice with lists](#voice-with-lists)
  - [Multiple voices and multiple scores](#multiple-voices-and-multiple-scores)
- [Genotype substructures](#genotype-substructures)
    - [Branches and leaves](#branches-and-leaves)
    - [Subexpressions](#subexpressions)
- [Initial conditions for generation of genotypes](#initial-conditions-for-generation-of-genotypes)
  - [Species characterization](#species-characterization)
  - [Vector of desired musical characteristics](#vector-of-desired-musical-characteristics)
    - [Weighted measurement of Euclidean distance](#weighted-measurement-of-euclidean-distance)
- [Generation, evolution and selection of specimens](#generation-evolution-and-selection-of-specimens)
- [Specimen data structure](#specimen-data-structure)
- [Specimen catalogue](#specimen-catalogue)
  - [Naming](#naming)
  - [Classification](#classification)
  - [Catalogue access](#catalogue-access)
- [Max user interface](#max-user-interface)

----------
# GenoMus overview
## Conceptual approach
## Flowchart 

----------  
# Definitions
- **genotype**: Function tree representing compositional procedures.
- **phenotype**: Music score generated by a genotype.
- **encoded genotype**: Genotype coded as an array of normalized floats within the closed interval [0, 1].
- **decoded genotype**: Genotype coded as a string that contains a function tree, executable in JavaScript.
- **encoded phenotype**: Phenotype coded as an array of normalized floats within the closed interval [0, 1].
- **decoded phenotype**: Phenotype converted to a format for notation or audio software, such as Max, Csound, Lilypond, etc.
- **specimen**: Genotype/phenotype pair, saved as a JSON file containing encoded and decoded versions of its code, metadata and many other useful analytical informations.
- **species**: Group of specimens that share the same parameter structure of their simplest musical events.
- **genotype function**: Minimum computable unit of a genotype. It is designed in a modular way to easily take other genotype functions as arguments.
- **parameter**: Normalized float &isinv; [0, 1] used to feed the functions' required arguments. These numeric values are leaves of the functional tree that gives rise to a genotype.
- **leaf**: Terminal node of a genotype functional tree, containing a parameter.
- **list**: Array of parameters.
- **event**: Simplest sonic element. In traditional music writing, a note. The default atributes of an event are: [duration, pitch, articulation, intensity]. An event can contain more than one pitch. events with more parameters can be set, for example, for electroacoustic works, where a sonic event could be defined by dozens of features. A note can consist of two or more concatenated pitches. events can be concatenated only sequentially (one after another, without overlapping). Overlapping effect among events inside the same voice can be achieved by means of articulation. An event can be extended to other domains beyond music, like visuals, lighting, etc., along with musical events, or standalone. 
- **voice**: Line of music (usually for an only instrument). A voice is a wrapper for a sequence of one or more events. A voice can consist of two or more voices sequentially concatenated  together (one after another, without overlapping). Each event inside a voice can contain more than one pitch. For instance, a sequence of major chords can be a single voice.
- **score**: Excerpt or a whole piece of music. A score is a wrapper for one or more voices. A score can consist of two or more scores together. Scores can be concatenated sequentially (one after another) or simultaneously (sounding together). The product of these concatenations is a new score. The event-voice-score structure is defined after [bach](https://www.bachproject.net/) paradigm, to facilitate the visualization and interactions with phenotypes in Max environment.
- **duration**: Time length from the beginning of an event to the beginning of the next event, into the same voice. 
- **pitch**: Each of the root frecuencies in an event.
- **articulation**: Length of the event sound. It can be different from the event duration. If articulation matchs the duration, a perfect legato among events will be played. Shorter or larger values for articulation will sound as staccato or lasciare vibrare effects.
- **intensity**: Dynamic of an event.
- **GenoMus function catalog**: JSON file that lists and characterizes all the available functions for genotype generation of a species.
- **function type identifier**: Prefix used to name functions, to ease the function type identification. The use of identifiers is not compulsory, but very convenient for readability of decoded genotypes.
- **function index**: Integer assigned incrementally to identify each function with a unique number in the GenoMus functions catalogue. 
- **encoded function index**: Float generated to identify each function with a unique number. These numbers are chosen using the function index as input for an algorithm designed to obtain an optimized distribution of these normalized identifiers &isinv; [0, 1].
- **eligible functions**: Set of functions that determine which ones can be chosen during the genotype generation process. Somehow, this set can characterize a composer or a style.
- **genotype seed**: Number used to initialize the pseudorandom number generator before the genotype generation process starts. It allows repeatable results. Ultimately, a genotype can be identified only by this number, since it determines the entire decision tree that generates it.
- **phenotype seed**: Number used to initialize the pseudorandom number generator before the genotype evaluation process starts, which allows producing repeatable phenotypes. When a genotype includes random processes, many different phenotypes from the same genotype can arise. In this case, each different result can be indentified with a phenotype seed. So, given specific initial conditions, a single specimen can be identified only by two integers: genotype and phenotype seeds.
- **rhythmic grid**: Data structure that characterizes a rhythmic pattern by specifying length, talea and other features.
- **harmonic grid**: Data structure that characterizes a harmony by specifying tonal center, pitch class set and other features.
- **talea**: Array of values that represents a sequence of relative durations (updated concept taken from ancient music).
- **prolatio**: Hierarchical time grid structure.
- **quantization**: Adjustment of relatives durations of a talea to a prolatio.

---------
# Anatomy of a genotype function

## Function name
As a convenient convention to improve the understanding of the function tree, **genotype functions** are named beginning with the type identifier, a letter that identifies their type of output (see [function types for genotypes](#function-types-for-genotypes)).

## Input arguments
All genotype functions in a function tree expect arguments received from another genotype function, except if the required argument is a **leaf**. The input arguments can only come from one of the predefined types of genotype function included in the referenced [GenoMus Function Library](#function-libraries).

The names of the input arguments are of free choice.

## Output data structure 
To enable automatic chaining of functions, all functions inside a genotype share the same output data structure. This output data is returned within an array according to the following order of elements:

| index | variable name  | data type                      | description
| ----- | -------------- | ------------------------------ | -----------
| 0     | **funcType**   | string                         | Function type according to its output (see [reference](#function-types-for-genotypes)).
| 1     | **decGen**  | string                         | Decoded genotype excerpt. Functional expression of the genotype branch computed until that node, including the function itself.
| 2     | **encPhen** | array of floats &isinv; [0, 1] | Encoded phenotype excerpt. Transformation of the input data made with the compositional procedures of the function itself.
| 3     | **phenLength** | integer                        | Number of phenotype events generated so far. Useful for subsequent functions to avoid overly large processes.
| 4     | **tempo**      | float                          | Tempo of the phenotype. The float uses the [durationF](#durationf-d) format to indicate the duration of a quarter note. Default value: 0.6 (equivalent to &#9833;= 60)
| 5     | **rhythm**     | dictionary                     | Rhythmic grid characterized with this [data structure](#rhythmic-grid).
| 6     | **harmony**    | dictionary                     | Harmonic grid characterized with this [data structure](#harmonic-grid).

First five elements are compulsory for every function inside a genotype. Informations about rhythm and harmony can be useful for subsequent functions, but they are optional. 

Variable names inside each genotype function are not compulsory, but is highly recommended to maintain the same nomenclature to improve code readability and reusability.

More fields can be added if needed, but always after the first seven preset items.

The **decoded genotype** is created only when the specimen is sent to another music software.

## Genotype function template

```
// description
var <iFunctionName> = function (argument1, argument2, ..., argumentN) {
    
    < check block > // checks that the execution of the function will produce a phenotype that satisfies the constraints of the predetermined initial conditions

    var funcType = "<functionType>"; // describes the type of the function itself
    var encPhen = []; // this array will contain the produced encoded phenotype
    
    < core block > // executes the musical transformations of the function, writing the results in the variable encPhenOut, and calculating at the end of the process the updated values of phenLength, tempo, rhythm and harmony.
    
    var decGen = "<iFunctionName>(" + argument1[1] + "," + + argument2[1] + "," + ... argumentN[1] + ")"; // creates a string as a self-reference of the functional expression that has been evaluated.
    return writeSubexprReturnData(funcType, decGen, encPhen, phenLength, tempo, rhythm, harmony);
};
```

The last line uses the auxiliary function **writeSubexprReturnData**, which stores all the subexpressions generated during the evaluation of the function tree so far, and returns the array with the [output data structure](#output-data-structure) described above.

---------
# Genotype function types
Genotype functions are classified by their output data. By convention, each type is has an identifier used as prefix for the names of all functions of that output type. 

---------
## Used function type identifiers
~~**a** **b** **c** **d** **e** **f** **g** **h** **i**~~ j k ~~**l** **m** **n** **o** **p** **q** **r** **s** **t** **u** **v** **w**~~ x y ~~**z**~~

---------
## Main structures

| function type   | identifier   | output
| --------------- | ------------ | --------
| **scoreF**      | **s**        | score
| **voiceF**      | **v**        | voice
| **eventF**      | **e**        | event
| **listF**       | **l**        | list of normalized floats &isinv; [0, 1]
| **paramF**      | **p**        | normalized parameter
| **leaf**        | -            | norm. parameter or specific format parameter

The **leaf** type is a flag for terminal nodes. This is not really a type of function, but a label to indicate that a new function will not be called.

---------
## Human-readable leaf parameters
Function types created to improve readability and manual editing of decoded genotypes. These functions can replace a **paramF** functions in a leaf position of function tree.

| function type      | identifier   | output
| ------------------ | ------------ | --------
| **notevalueF**     | **n**        | normalized duration from usual number used for note values (1 = whole note)
| **durationF**      | **d**        | normalized duration from time in seconds
| **midipitchF**     | **m**        | normalized pitch from standard MIDI pitch
| **frequencyF**     | **f**        | normalized pitch from frequency in Hz
| **articulationF**  | **a**        | normalized relative articulation (1 is whole duration of the note, 2 is double duration)
| **intensityF**     | **i**        | normalized intensity from standard MIDI velocity
| **goldenintegerF** | **z**        | normalized value from integer &isinv; [0, 514261]
| **quantizedF**     | **q**        | normalized value from integer &isinv; [-36, 36]

---------
## Human-readable lists

These functions receive a list of human-readable leaf parameters and return a normalized list, which can be seamlessly integrated into automatic processes.

| function type       | identifier   | output
| ------------------- | ------------ | --------
| **lnotevalueF**     | **ln**       | list of normalized durations from list of note values (1 = whole note)
| **ldurationF**      | **ld**       | list of normalized durations from list of duration in seconds
| **lmidipitchF**     | **lm**       | list of normalized pitches from list of MIDI pitches
| **lfrequencyF**     | **lf**       | list of normalized pitches from frequencies in Hz
| **larticulationF**  | **la**       | list of normalized relative articulations from list of relative articulations
| **lintensityF**     | **li**       | list of normalized intensities from MIDI velocities
| **lgoldenintegerF** | **lz**       | list of normalized values from list of integer &isinv; [0, 514261]
| **lquantizedF**     | **lq**       | list of normalized values from list of integer &isinv; [-36, 36]

---------
## Domain-specific formats
Function types created to manage specific types of data (some of them are still purely theoretical)

| function type   | identifier   | output
| --------------- | ------------ | --------
| **operationF**  | **o**        | result of an arithmetic operation, useful to construct recursive mathematical expressions inside a genotype
| **booleanF**     | **b**        | boolean value (only 0 or 1)
| **rhythmF**     | **r**        | rhythmic pattern (nested array of floats &isinv; [0, 1])
| **harmonyF**    | **h**        | pitch class sequence, useful for specifying scales, modes, chords, pitch aggregates, harmonic series, etc.
| **catalogueF**  | **c**        | pointer to an external genotype from a specimen catalogue (to be used with functions referencing external data)
| **genotypeF**   | **g**        | raw encoded genotype (array of floats &isinv; [0, 1])
| **txtF**        | **t**        | string
| **waveF**       | **w**        | encoded path to read data from an stored audio file

---------
## Manual manipulation of genotypes
Functions to be used typing manually on the genotypes to get a more controlled evolution.

| function type   | identifier   | output
| --------------- | ------------ | --------
| **userF**       | **u**        | these functions perform very different manipulations on part of a genotype, acting as a metalevel of functional control

User functions use uppercase letters to be easily found during manual editing processes. Some examples of this type:
- **uEVOLVE** (*expr*) - contains the part of a genotype to be transformed, freezing the rest
- **uFREEZE** (*expr*) - block a part of a genotype to be preserved from transformations
- **uFLATTEN** (*expr*) - render part of a genotype into a simple declarative score/voice/event (phenotype)

---------
# Parameter mapping
A GenoMus function tree expects generic parameters (floats &isinv; [0, 1]) as leaves, regardless arguments' domain. When computing a phenotype, these numbers must be mapped to correct ranges and scales to represent duration, pitch, etc.

Human-readable function types use specific user-friendly formats for each argument. These non generic parameters are first mapped to a normalized interval [0, 1] to be later evaluated and encoded as stardard normalized paramenters.

In general, these maps are not linear (straight line maps). For each type of parameter, a Gaussian approach is employed, trying to cover a wide range of values for each category, but at the same time modeling the conversion so that central values (specially the range [0.25, 0.75]) map to the musical values that appear more frequently.

To work seamlessly with Max, decimal part of floats are truncated to display only 6 digits on decoded genotypes.

Since each species could require new domain-specific parameters, for each new parameter a mapping similar to those presented below must be defined.

Parameter mapping is used in several contexts:
- **To display decoded genotypes** in a more human-readable way, converting normalized values to domain-specific ranges when possible.
- **To encode genotypes**, converting arguments entered manually using user-friendly function types to normalized values.
- **To render phenotypes** (scores or soundfiles), converting normalized values to domain-specific ranges.

--------
## Duration

### **notevalueF** (n) 

Input can be the usual ratio for each note value or a float. This value is relative, and its actual duration will depend on the current tempo mark. 

Conversion formulae: normalized parameter _**p**_ to note value ratio _**v**_ and inverse ([graph](https://www.desmos.com/calculator/ysm8zt5rbl)):

<img src="formulae/norm2notevalue.svg" width="100">
<img src="formulae/notevalue2norm.svg" width="175">
<img src="formulae/norm2notevalue_graph.png" width="250">

| [0, 1] | *v* (float)  | *v* (ratio) | notation (Am) / (Br)                    | seconds if &#9833;= 60 
| ------ | ------------ | ----------- | --------------------------------------- | ---------------------- 
| 0      | 0.00390625   | 1/256       | 256th note / demisemihemidemisemiquaver | 0.015625               
| 0.1    | 0.0078125    | 1/128       | 128th note / semihemidemisemiquaver     | 0.03125                
| 0.2    | 0.015625     | 1/64        | 64th note / hemidemisemiquaver          | 0.0625                 
| 0.3    | 0.03125      | 1/32        | 32th note / demisemiquaver              | 0.125                  
| 0.4    | 0.0625       | 1/16        | 16th note / semiquaver                  | 0.25                   
| 0.5    | 0.125        | 1/8         | 8th note / quaver                       | 0.5                    
| 0.6    | 0.25         | 1/4         | quarter note / crotchet                 | 1                      
| 0.7    | 0.5          | 1/2         | half note / minim                       | 2                      
| 0.8    | 1            | 1           | whole note / semibreve                  | 4                      
| 0.9    | 2            | 2           | double note / breve                     | 8                      
| 1.0    | 4            | 4           | quadruple note / longa                  | 16                     

#### Reference table for main noteValues



<img src="figures/all_noteValues.svg" width="900">

<sub>The numbers below the figures indicate note values as part of triplets and quintuplets.</sub>

### **durationF** (d) 

Conversion formulae: normalized parameter _**p**_ to seconds _**s**_ and inverse ([graph](https://www.desmos.com/calculator/pn1nbunlcz)):

<img src="formulae/norm2duration.svg" width="100">
<img src="formulae/duration2norm.svg" width="175">
<img src="formulae/norm2seconds_graph.png" width="250">

| [0, 1] |  dur. (s)   
| ------ | -------- 
| 0      | 0.015625 
| 0.1    | 0.03125  
| 0.2    | 0.0625   
| 0.3    | 0.125    
| 0.4    | 0.25     
| 0.5    | 0.5      
| 0.6    | 1        
| 0.7    | 2        
| 0.8    | 4        
| 0.9    | 8        
| 1.0    | 16       

--------
## Pitch
### **midipitchF** (m)

Linear conversion keeping encoded normalized data easily readable.

Conversion formulae: normalized parameter _**p**_ to MIDI pitch _**m**_ and inverse ([graph](https://www.desmos.com/calculator/atupolxw6d)):

<img src="formulae/norm2midipitch.svg" width="125">
<img src="formulae/midipitch2norm.svg" width="100">
<img src="formulae/norm2midipitch_graph.png" width="250">s

| [0, 1]  |  MIDI pitch   | Notation
| ------  | ------------- | ----------
| 0       | 12            | C<sub>0</sub>
| 0.09    | 21            | A<sub>0</sub> <sub>(lowest piano key)</sub>
| 0.12    | 24            | C<sub>1</sub>
| 0.24    | 36            | C<sub>2</sub>
| 0.36    | 48            | C<sub>3</sub>
| 0.48    | 60            | C<sub>4</sub> <sub>(middle C)</sub>
| 0.5     | 62            | D<sub>4</sub> <sub>(central note between flats and sharps)</sub>
| 0.60    | 72            | C<sub>5</sub>
| 0.72    | 84            | C<sub>6</sub>
| 0.84    | 96            | C<sub>7</sub>
| 0.96    | 108           | C<sub>8</sub> <sub>(highest piano key)</sub>
| 1.0     | 112           | E<sub>8</sub>
 
### **frequencyF** (f)

Conversion formulae: normalized parameter _**p**_ to frequency in hertz _**h**_ and inverse ([graph](https://www.desmos.com/calculator/ixocptnpba)):

<img src="formulae/norm2hertz.svg" width="101">
<img src="formulae/hertz2norm.svg" width="110">
<img src="formulae/norm2hertz_graph.png" width="250">

| [0, 1]   |  Hz      
| -------- | -------- 
| 0        | 0.000001 
| 0.1      | 2        
| 0.2      | 32       
| 0.3      | 162 
| 0.385129 | 440 
| 0.4      | 512      
| 0.5      | 1250     
| 0.6      | 2592     
| 0.7      | 4802     
| 0.8      | 8192     
| 0.9      | 13122    
| 1.0      | 20000    

--------
## Articulation

Articulation can be used in two modes:

- absolute articulation: The duration of the sound is measured in seconds, and is independent of tempo and event duration. The **durationF** function type is used for this articulation. 
- relative articulation: the duration of the sound is a ratio of the event duration. 1 means that the sound will last the whole duration, 0.5 is the half of the event duration, and so on. For this proportional articulation the function type **articulationF** must be employed.

### **articulationF** (a)
Conversion formulae: normalized parameter _**p**_ to relative articulation _**a**_, as a proportion of event duration ([graph](https://www.desmos.com/calculator/i5jiq4k9ah)):

<img src="formulae/norm2articulation.svg" width="63">
<img src="formulae/articulation2norm.svg" width="82">
<img src="formulae/norm2articulation_graph.png" width="250">

| [0, 1]   |  proportion of event duration | notation
| -------- | ----------------------------- | --------
| 0        | 0                             | silence
| 0.1      | 0.005739                      |
| 0.2      | 0.037768                      | *staccatissimo*
| 0.3      | 0.113708                      |
| 0.4      | 0.248547                      | *staccato*
| 0.5      | 0.455866                      |    
| 0.51729  | 0.5                           | *non legato*
| 0.6      | 0.748296                      |
| 0.66     | 0.969596                      |
| 0.667539 | 1                             | *legato*
| 0.7      | 1.137769                      |
| 0.8      | 1.635658                      | *legatissimo*
| 0.861429 | 2                             |
| 0.9      | 2.252888                      |
| 1.0      | 3                             | *lasciare vibrare*

--------
## Intensity
### **intensityF** (i)
Conversion formulae: normalized parameter _**p**_ to intensity _**i**_ in standard MIDI velocity and inverse ([graph](https://www.desmos.com/calculator/cisndyw3gs)):

<img src="formulae/norm2intensity.svg" width="72">
<img src="formulae/intensity2norm.svg" width="67">
<img src="formulae/norm2intensity_graph.png" width="250">

| [0, 1] | MIDI velocity | notation
| ------ | ------------- | --------
| 0      | 0             |  silence
| 0.06   | 7.62          | **_pppp_**
| 0.15   | 19.05         | **_ppp_**
| 0.25   | 31.75         | **_pp_**
| 0.33   | 41.91         | **_p_**
| 0.4    | 50.8          | **_mp_**
| 0.5    | 63.5          | **_mf_**
| 0.66   | 83.82         | **_f_**
| 0.75   | 95.25         | **_ff_**
| 0.9    | 114.3         | **_fff_**
| 1.0    | 127           | *tutta forza*

---------
## Quantized steps
### **goldenintegerF** (z)

A function of type goldenintegerF is useful for contexts where positive integer numbers are needed, but relative big distances among consecutives integers are convenient when they are normalized. When converted to normalized values, a sequence of *golden integers* always maintains a balanced distribution over the entire interval [0, 1], regardless of the number of elements employed. However, when the number of elements coincides with a Fibonacci number, the distribution is optimal.  

This conversion is specifically used to assign numeric identifiers to indexed elements such as functions or genotype subexpressions.

This format takes advantage of the golden angle properties using this formula to map integers _**z**_ &#8712; [0, 514261] to normalized parameter _**p**_ &#8712; [0, 1] and inverse:

<img src="formulae/goldenint2norm.svg" width="164">

<img src="formulae/norm2goldeninteger.svg" width="360">


where *&#981;* is the golden ratio (&#8776; 1.618034):

<img src="formulae/golden_ratio.svg" width="100">

Normalized values are rounded to have only six digits after the decimal point. Using this truncated format there are 514262 different values available until a recurrence occurs.

This graph shows the distribution of the first 100 positive integers mapped within interval [0, 1] :

<img src="formulae/encoded_function_index_graph.png" width="750">

| golden integer | [0, 1]
| -------------- | ------
| 0              | 0
| 1              | 0.618034
| 2              | 0.236068
| 3              | 0.854102
| 4              | 0.472136
| 5              | 0.09017
| 6              | 0.708204
| ...            | ...

---------
### **quantizedF** (q)

This format is useful for different contexts where integer numbers can be much more readable, but only small positive and negative quantities are needed. A possible application may be, for instance, to write a sequence of melodic intervals using a diatonic scale as the step basis. 

Conversion formulae: normalized parameter _**p**_ to quantized steps _**q**_ ([graph](https://www.desmos.com/calculator/3vy4gwjxcu)):

<img src="formulae/norm2quantized.svg" width="440">

The inversion is made with a lookup table.

<img src="formulae/norm2quantized_graph.png" width="450">

| [0, 1] |  integer steps      
| ------ | -------------------
| 0      | -36                   
| 0.0005 | -35                
| 0.001  | -34               
| 0.003  | -33               
| 0.006  | -32               
| 0.008  | -31                
| 0.01   | -30                
| 0.015  | -29               
| 0.02   | -28               
| 0.025  | -27               
| 0.03   | -26                 
| 0.04   | -25                 
| 0.045  | -24                 
| 0.05   | -23                 
| 0.06   | -22                 
| 0.07   | -21
| 0.08   | -20                 
| 0.09   | -19               
| 0.1    | -18               
| 0.11   | -17               
| 0.12   | -16                 
| 0.14   | -15                 
| 0.15   | -14                 
| 0.16   | -13                 
| 0.18   | -12                 
| 0.2    | -11
| 0.21   | -10
| 0.23   | -9               
| 0.25   | -8               
| 0.27   | -7               
| 0.3    | -6                 
| 0.32   | -5                 
| 0.33   | -4                 
| 0.36   | -3                 
| 0.4    | -2                 
| 0.45   | -1
| 0.5    | 0
| 0.55   | 1
| 0.6    | 2
| 0.64   | 3
| 0.67   | 4
| 0.68   | 5
| 0.7    | 6
| 0.73   | 7
| 0.75   | 8
| 0.77   | 9
| 0.79   | 10
| 0.8    | 11
| 0.82   | 12
| 0.84   | 13
| 0.85   | 14
| 0.86   | 15
| 0.88   | 16
| 0.89   | 17
| 0.9    | 18
| 0.91   | 19
| 0.92   | 20
| 0.93   | 21
| 0.94   | 22
| 0.95   | 23
| 0.955  | 24
| 0.96   | 25
| 0.97   | 26
| 0.975  | 27
| 0.98   | 28
| 0.985  | 29
| 0.99   | 30
| 0.992  | 31
| 0.994  | 32
| 0.997  | 33
| 0.999  | 34
| 0.9995 | 35
| 1      | 36


---------
## rhythmF

The output of a **rhythmF** function is an abstract time grid determined by a nested array with relative durations. This grid is called **prolatio**, and is used to quantize the values of a rhythmic pattern. 

The values inside a prolatio array are not absolute durations, but only proportions among themselves. For example, *prolationes* `[3,1,4]` and `[0.63,0.21,0.84]` are equivalent. A prolatio need a reference value to be rendered as a series of durations. Application of this prolatio to a half note (1/2) as total length:

<img src="figures/prolatio_basic.svg" width="117">

Each value of a prolatio can in turn be subdivided into another prolatio using a subarray in the next position. The last value in this prolatio can be subdivided in this way:

`[3,1,4,[1,1,1,1,1]]`, with this result:

<img src="figures/prolatio_basic_2.svg" width="170">

Obviously, each subarray must have at least two values to produce a subdivision at the next depth level of the prolatio. A prolatio with the scheme `[a,[d,e],b,c,[f,g,[i,j],h]]` has three level of subdivisions of the duration set by the variable **totalValue**:

<img src="figures/prolatio_tree.svg" width="140">

Prolationes can be arbitrarily complex. A simple array like `[1,[2,3],1,[1,[1,4],4,2],1,[1,1,[3,4,4]]]` produces nested tuplets (with a whole note as total duration):

<img src="figures/prolatio_complex.svg" width="476">

If more levels of subdivision are required but not specified, simple binary subdivisions are made by default.

These examples use integers for simplicity, but the output of a rhythmF function is always a nested array including only floats &isinv; [0, 1]. For instance, the last example of prolatio would be rescaled so that the maximum value was 1, returning this normalized nested array:

`[0.25,[0.5,0.75],0.25,[0.25,[0.25,1],1,0.5],0.25,[0.25,0.25,[0.75,1,1]]]`

All the functions working with a prolatio perform a normalization before processing or returning data, so simple proportions of integers as in the previous examples can be manually introduced in a decoded genotype. 

---------
## harmonyF

The output of a **harmonyF** function is a sequence of floats within interval \[0, 12\). 

This array is not a pitch class set but a pitch class sequence, because in some contexts the order determines certain algorithmic operations. However, this format can also serve as a pitch class set when needed.

Numbers represent pitches with the usual pitch class notation (0 = C, 1 = C&#9839;, etc), but in many occasions these pitches are transposed. So it is better to contemplate this sequence as an abstract series of intervals, in which C is used as baseline by default. Values can include a decimal part to denotate microtonal intervals.



---------
# Characterization of underlying musical patterns

During the evaluation of a genotype function tree, functions complement output data with auxiliary information concerning underlying musical patterns regarding to rhythm and harmony. These data are useful for the analysis and automatic characterization of genotypes, and for certain functions that use this data directly for the evaluation of phenotypes.

Other characteristics beyond rhythm and harmony can be added according to the needs and the event format of each species.

---------
## Rhythmic grid

A rhythmic pattern can be expressed as a dictionary containing informations to be used by other functions to map durations. These data represent a rhythmic pattern and its interrelations with a time grid and with the level of general quantization. Using this dictionary, certain functions adjust their values to get different rhythmic structures and analytical information.

A **rhythmic grid** is coded into an array following this data structure:

| index | feature          | data format          | description
| ----- | ---------------- | -------------------- | ----------- 
| 0     | **totalValue**   | notevalueF           | pattern length
| 1     | **talea**        | rhythmF              | rhythmic pattern (regardless of central value)
| 2     | **prolatio**     | rhythmF              | successive levels of divisions in the time grid to which the rhythmic values will be adjusted
| 3     | **quantization** | float &isinv; [0, 1] | degree of adjustment to quantization scheme (higher means more rhythmic complexity)

---------
### totalValue

The duration of reference to perform all rhythmic pattern transformations is determined by **totalValue**, formatted according to the mapping of [**notevalueF**](#notevaluef-n) functions.

---------
### talea

A **talea** is a rhythmic pattern, a sequence of numbers representing relative durations. Its format can be a simple float array (no normalization is required), or can be derived from a nested array as output of a [**rhythmF**](#rhythmf) function.

The order of values in a **talea** matters, because the position within the sequence determines the priority of taken values for low degrees of quantization (the first, the most important).

---------
### prolatio

A **prolatio** is a nested time grid used to adjust the raw values received from a talea. A prolatio follow the format of [**rhythmF**](#rhythmf) functions output. 

---------
### quantization

| quantization | result
| ------------ | ------
| 0            | all values are quantized to the totalValue duration (all events are played simultaneously, prolatio is not taken into account)
| (0, 1)       | gradual quantization using progressive levels of prolatio depth
| 1            | no quantization applied, values mapped with full rhythmic resolution (prolatio is not taken into account)

---------
### Example of rhythmic motives

The following tables show how increasing degrees of quantization of this rhythmic grid: 

```
{
    "totalValue": 1,
    "talea": [0.1,0.1,0.4,0.8,0.4,0.5],
    "prolatio": [2,[1,[1,1],1,[1,1],1],4,1,[2,[3,1],1,1],1,[2,1]],
    "quantization": <float within interval [0, 1]>
}
```

First of all, the talea `[0.1,0.1,0.4,0.8,0.4,0.5]` is rescaled to `[0.044,0.044,0.174,0.348,0.174,0.216]` Now, the sum of all the numbers in the sequence is 1. The relative durations of this talea can be visualized as horizontal segments: 

<img src="figures/talea.svg" width="500">

The next step is to determine quantization thresholds based on the prolatio depth levels. In this example, the prolatio has three levels that are mapped to the intervals (0, &#8531;], (&#8531;, &#8532;] and (&#8532;, 1).

| **quantization** = 0                               | totalValue = 1 <sub>(whole note)</sub>
| -------------------------------------------------- | -----
| **raw talea** (rescaled)                           | `[0.044,0.044,0.174,0.348,0.174,0.216]`
| **prolatio** depth = 0 (code)                      | Prolatio is not used, all values converge to **totalValue**
| **prolatio** depth = 0 (score)                     | <img src="figures/prolatio_ex0.svg" width="78">
| **talea to prolatio quantization** (visualization) | <img src="figures/q0.svg" width="500">
| **quantized talea**                                | `[1]`
| **final result** (score)                           | <img src="figures/prolatio_ex0.svg" width="78">

| 0 < **quantization** &#8804; &#8531;               | totalValue = 1 <sub>(whole note)</sub>
| -------------------------------------------------- | -----
| **raw talea** (rescaled)                           | `[0.044,0.044,0.174,0.348,0.174,0.216]`
| **prolatio** depth = 1 (code)                      | `[2,4,1,1]`
| **prolatio** depth = 1 (score)                     | <img src="figures/prolatio_ex1.svg" width="130">
| **talea to prolatio quantization** (visualization) | <img src="figures/q1-3.svg" width="500">
| **quantized talea**                                | `[0.25,0.5,0.25]`
| **final result** (score)                           | <img src="figures/final_quant_ex1.svg" width="108">

| &#8531; < **quantization** &#8804; &#8532;         | totalValue = 1 <sub>(whole note)</sub>
| -------------------------------------------------- | -----
| **raw talea** (rescaled)                           | `[0.044,0.044,0.174,0.348,0.174,0.216]`
| **prolatio** depth = 2 (code)                      | `[2,[1,1,1],4,1,[2,1,1],1,[2,1]]`
| **prolatio** depth = 2 (score)                     | <img src="figures/prolatio_ex2.svg" width="270">
| **talea to prolatio quantization** (visualization) | <img src="figures/q2-3.svg" width="500">
| **quantized talea**                                | `[0.083, 0.167, 0.5, 0.062, 0.188]`
| **final result** (score)                           | <img src="figures/final_quant_ex2.svg" width="169">

| &#8532; < **quantization** < 1                     | totalValue = 1 <sub>(whole note)</sub>
| -------------------------------------------------- | -----
| **raw talea** (rescaled)                           | `[0.044,0.044,0.174,0.348,0.174,0.216]`
| **prolatio** depth = 3 (code)                      | `[2,[1,[1,1],1,[1,1],1],4,1,[2,[3,1],1,1],1,[2,1]]`
| **prolatio** depth = 3 (score)                     | <img src="figures/prolatio_ex3.svg" width="400">
| **talea to prolatio quantization** (visualization) | <img src="figures/q3-3.svg" width="500">
| **quantized talea**                                | `[0.042, 0.042, 0.168, 0.5, 0.048, 0.2]`
| **final result** (score)                           | <img src="figures/final_quant_ex3.svg" width="280">

| **quantization** = 1                               | totalValue = 1 <sub>(whole note)</sub>
| -------------------------------------------------- | -----
| **raw talea** (rescaled)                           | `[0.044,0.044,0.174,0.348,0.174,0.216]`
| **prolatio**                                       | Prolatio is not needed because there is no quantization
| **talea to prolatio** (visualization)              | <img src="figures/q1.svg" width="500">
| **quantized talea** (no quantization is done)      | `[0.044,0.044,0.174,0.348,0.174,0.216]`
| **final result** (score)                           | <img src="figures/prolatio_Q1-0.svg" width="230">

It is important to note that some of the rendered values could be rests. Rest are produced when event atributes as articulation or intensity are set to 0. 

The final result of a rhythmic grid is a sequence of floats. Consequently, a processed rhythmic grid can be a talea for a new grid.

--------
## Harmonic grid

A harmony can be expressed as a dictionary containing informations to be used by other functions to map pitches. These data is a representation of a group of pitches (usually a chord) and its interrelations with a pitch class set (usually a mode) and with the level of general chromatism. Using this information, certain functions adjust their values to the grid of pitches that fits this harmony and extract analytical information.

A **harmonic grid** is coded into an array following this data structure:

| index | feature          | data format          | description
| ----- | ---------------- | -------------------- | ----------- 
| 0     | **root**         | midipitchF           | main reference pitch (usually a chord's root)
| 1     | **chord**        | harmonyF             | pitch class sequence with the harmony pitches (regardless of tonal center)
| 2     | **mode**         | harmonyF             | pitch class sequence (usually, a scale) containing the chord pitches using C (pitch class 0) as root 
| 3     | **chromaticism** | float &isinv; [0, 1] | tolerance to chromatic notes (higher means more chromatic results)

---------
### root, chord and mode

The **root** note is used as origin to transpose the rest of harmonic parameters.

A **chord** is a set of notes that determine the leading harmony of a passage, while a **mode** is usually related to scales, and is a superset that contains the chord.

Note that chord and mode are not pitch class sets because order matters. The position within the pitch sequences determines the priority of each pitch for low degrees of chromaticism (the first, the most important). 

Root, chord and mode parameters can lead to very different results. Data types analog to harmonyF can be developed to create music with another tuning, microtonality or without equally-tempered intervals.

---------
### chromaticism

**chromaticism** is applied as a kind of pitch quantization. The raw pitch values of a melodic sequence is *rounded* to a series of pitch classes. The degree of chromaticism is denoted with a normalized value, which determines how complex is the sequence of eligible pitch classes.

This is the meaning of different values for chromaticism:

| chromaticism (*c*)        | result
| ----------------------- | ------
| 0 &#8804; *c* &#8804; 0.5 | only chord pitch classes are used, progressively incorporated as *c* is higher (0 &rarr; only 1 pitch class, 0.5 &rarr; all chord pitch classes)
| 0.5 < *c* &#8804; 0.8     | mode pitches classes are progressively integrated (0.500001 &rarr; only 1 new pitch class added, 0.8 &rarr; complete mode is employed)
| 0.8 < *c* &#8804; 1       | all remaining pitch classes of the chromatic scale are integrated

--------
### Example of harmonic motives

Given this harmonic grid:

```
{
    "root": 0.68124,
    "chord": [1,0,5,8,3],
    "mode": [0,3,1,5,8,6,11,10],
    "chromaticism": <float within interval [0, 1]>
}
```

The algorithm follows these steps:
1. Set the tonal center with **root**. The value `0.68124` correspond to the pitch A&#9837;, applying this [conversion](#midipitchf-m). 
2. Transpose pitch classes of **chord** and **mode** from C to G&#9839; (or A&#9837;) as root, keeping the same order: 

`[11,0,5,8,3]` &rarr; `[7,8,1,4,11]`:

<img src="figures/chord.svg" width="261"> 

`[0,3,1,5,8,6,11,10]` &rarr; `[8,11,9,1,4,2,7,6]`

<img src="figures/mode.svg" width="348"> 

3. Check the pitch classes of mode which are not part of chord and extract this ordered subsequence. In this case, the result is `[9,2,6]`.
4. Calculate the ranges of values corresponding to the increasing degrees of chromaticism, and transform input data accordingly.

The following tables show how increasing degrees of chromaticism affect to this grid, and the effect of applying it to a two-voices music excerpt (enharmonic differences are not relevant): 

| chromaticism (*c*) ranges of values | eligible pitch classes        | result
| ----------------------------------- | ----------------------------- | ----
| 0 &#8804; *c* < 0.1                 | `[7]` (monochordal)                         | <img src="figures/excerpt-chromat-0.svg" width="200"> 
| 0.1 &#8804; *c* < 0.2               | `[7,8]`                                     | <img src="figures/excerpt-chromat-0-1.svg" width="200">
| 0.2 &#8804; *c* < 0.3               | `[7,8,1]`                                   | <img src="figures/excerpt-chromat-0-2.svg" width="200">
| 0.3 &#8804; *c* < 0.4               | `[7,8,1,4]`                                 | <img src="figures/excerpt-chromat-0-3.svg" width="200">
| 0.5 &#8804; *c* < 0.5               | `[7,8,1,4,11]` (complete chord)             | <img src="figures/excerpt-chromat-0-4.svg" width="200">
| 0.5 &#8804; *c* < 0.6               | `[7,8,1,4,11,9]`                            | 
| 0.6 &#8804; *c* < 0.7               | `[7,8,1,4,11,9,2]`                          | 
| 0.7 &#8804; *c* < 0.8               | `[7,8,1,4,11,9,2,6]` (complete mode)        | <img src="figures/excerpt-chromat-0-5.svg" width="200">
| 0.8 &#8804; *c* &#8804; 1           | `[0,1,2,3,4,5,6,7,8,9,10,11]` (all pitches) | <img src="figures/excerpt-chromat-1.svg" width="200">


---------
# Function libraries
A GenoMus Function Library is a JSON file that contains all available functions for genotype generation of a specific species.

## Function library data structure 

A GenoMus Function Library contains these blocks:
- **"metadata"**: 
  - **"species"**: name of the species.   
  - **"parametersStructure"**: basic event parameter structure. 
  - **"user"**: username
  - **"version"**: version number of the catalogue.
  - **"updated"**: date of last update.
  - ...
- **"outputType"**: all functions for genotype generation, grouped according to their output type.
- **"functionIndex"**: all functions for genotype generation, enumerated by their order of inclusion, along with their encoded function index.

## Indexing a function in a GenoMus Function Library
Functions are listed following this format:
```
"outputType": {
    "<functionType>": {
        "<functionName>": {
            "arguments": ["<functionType>", "<functionType>", ...],
            "description": "String describing what the function does.",
        "metadata": {
            "date": (date of creation, in compressed style),
            "creator": "<username>",
            ... (optional information if needed.)
        },
        ...
    },
    "<functionType>": {
    ...
}
```
The **description** and **metadata** fields are optional, but very helpful to understand quicky the processes in a genotype, and to add further informations and documentation about the function or the programmer.

Furthermore, each function must be included in the list of function index numbers:
```
"functionIndex": {
    1: {
        "functionName": 0.618034
    },
    2: {
        "functionName": 0.236068
    },
    ...
}
```
The integer index identifies the function. The float is the *encoded function index*. It is a number to map the function within the normalized interval [0, 1]. Encoded genotypes use this float to map all functions optimizing the maximal distance among functions into the interval. That's a critical issue for the automatic characterization of genotypes by machine learning techniques. 

Index numbers must correspond to only one function. To maintain the consistency of the library, an indexed function should not change its index numbers.

Index numbers of functions that use [human-readable leaf parameters](#human-readable-leaf-parameters) are assimilated to their standard equivalent functions with normalized parameters, and share the same index. Thus, encoded genotypes remain identical, regardless of whether human-readable conversions have been used. 

---------
## Encoded function index generation

Encoded function indexes are generated using a golden angle iteration mapped on the [0, 1] interval using this formula:

<img src="formulae/encoded_function_index.svg" width="180">

where *&#981;* is the golden ratio (&#8776; 1.618034), _**f<sub>e</sub>**_ is the index to identify the function in encoded genotypes and _**f<sub>d</sub>**_ is the correspondent decoded index, which is asigned incrementally in the catalogue. Encoded index numbers are rounded to have only six digits after the decimal point. Using this truncated format there are 514262 different indexes available until a recurrence occurs.

This map is used as the quantized function type **goldenintegerF** too [(more info)](#goldenintegerf-z).

From the *functionIndex* dictionary, an inverse dictionary is automatically created by rearranging the functions according to their ascending encoded index, following this format:

```
"encodedFunctionIndexes": {
    "0.236068": "functionNameX",
    "0.618034": "functionNameY",
    ...
}
```

This works as a useful lookup table for some automatic and manual processes.

---------
# Core functions
A GenoMus Function Library must include a collection of essential functions to perform basic operations for the generation of phenotypes. For each function type, the library has an identity function and other additional functions dedicated to the fundamental manipulations of that data category. As said before, lowercase prefixes indicate function types according to their output. 

This set of core functions are identified with the first index numbers of the library.

*This is still an incomplete list.*

---------
## Identity functions
An identity function simply pass its arguments without any musical transformation apart from formatting the output data accordingly when necessary. For each function type exists an identity function. 

For the sake of simplicity, identity functions are named using only their corresponding function type identifiers. They serve primarily as wrappers and testing functions.

Both function indexes, ordinal and encoded function index (smaller) are shown.

| function name | function type       | function index        | example decoded genotype &rarr; encoded phenotype
| ------------- | ------------------- | --------------------- | -------------------------------------------------
| `p`           | **paramF**          | 0 <sub>0</sub>        | `"p(.5)"` &rarr; `[0.5]` 
| `l`           | **listF**           | 1 <sub>.618034</sub>  | `"l([0,.3,1,.8])"` &rarr; `[0,0.3,1,0.8]`
| `e`           | **eventF**          | 2 <sub>.236068</sub>  | `"e(p(.5),p(.4),p(0),p(.8))"` &rarr; `[0.5,0.618034,0.4,0,0.8]` 
| `v`           | **voiceF**          | 3 <sub>.854102</sub>  | `"v(e(p(.5),p(.4),p(0),p(.8)))"` &rarr; `[0,0.5,0.618034,0.4,0,0.8,1]` 
| `s`           | **scoreF**          | 4 <sub>.472136</sub>  | `"s(v(e(p(.5),p(.4),p(0),p(.8))))"` &rarr; `[0,0,0.5,0.618034,0.4,0,0.8,1,1]` 
| `n`           | **notevalueF**      | 5 <sub>.09017</sub>   | `"n(1/8)"` &rarr; `[0.5]`
| `d`           | **durationF**       | 6 <sub>.708204</sub>  | `"d(1)"` &rarr; `[0.6]`
| `m`           | **midipitchF**      | 7 <sub>.326238</sub>  | `"m(60)"` &rarr; `[0.48]`
| `f`           | **frequencyF**      | 8 <sub>.944272</sub>  | `"f(440)"` &rarr; `[0.385129]`
| `a`           | **articulationF**   | 9 <sub>.562306</sub>  | `"a(.5)"` &rarr; `[0.51729]`
| `i`           | **intensityF**      | 10 <sub>.18034</sub>  | `"i(127)"` &rarr; `[1]`
| `z`           | **goldenintegerF**  | 11 <sub>.798374</sub> | `"z(1)"` &rarr; `[0.618034]`
| `q`           | **quantizedF**      | 12 <sub>.416408</sub> | `"q(-2)"` &rarr; `[0.4]`
| `r`           | **rhythmF**         | 13 <sub>.034442</sub> | `"r([0,6,20,[2,1],16])"` &rarr; `[0,0.3,1,[1,0.5],0.8]`
| `h`           | **harmonyF**        | 14 <sub>.652476</sub> | `"h([0.03,0.02,0.69])"` &rarr; `[3,2,9]`
| `ln`          | **lnotevalueF**     | 15 <sub>.27051</sub>  | `"ln([1/8,1,1/2])"` &rarr; `[0.5,0.8,0.7]`
| `ld`          | **ldurationF**      | 16 <sub>.888544</sub> | `"ld([8,1,2])"` &rarr; `[0.9,0.6,0.7]`
| `lm`          | **lmidipitchF**     | 17 <sub>.506578</sub> | `"lm([70,69,71])"` &rarr; `[0.58,0.57,0.59]`
| `lf`          | **lfrequencyF**     | 18 <sub>.124612</sub> | `"lf([162,32,4802])"` &rarr; `[0.3,0.2,0.7]`
| `la`          | **larticulationF**  | 19 <sub>.742646</sub> | `"la([1,1,0.5])"` &rarr; `[0.667539,0.667539,0.51729]`
| `li`          | **lintensityF**     | 20 <sub>.36068</sub>  | `"li([80,90])"` &rarr; `[0.629921,0.708402]`
| `lz`          | **lgoldenintegerF** | 21 <sub>.978714</sub> | `"lz([10,8,6,3])"` &rarr; `[0.18034,0.944272,0.708204,0.854102]`
| `lq`          | **lquantizedF**     | 22 <sub>.596748</sub> | `"lq([10,-10,0,-3,2])"` &rarr; `[0.79,0.21,0.5,0.36,0.6]`
| `o`           | **operationF**      | 23 <sub>.214782</sub> | `"o(.5)"` &rarr; `[0.5]`
| `b`           | **booleanF**        | 24 <sub>.832816</sub> | `"b(.5)"` &rarr; `[1]`

---------
## Internal autoreferences
| name        | index                          | description
| ----------- | ------------------------------ | -----------
| `pAutoRef`  | <sub>not yet implemented</sub> | points to a previous parameter
| `eAutoRef`  | <sub>not yet implemented</sub> | points to a previous event
| `lAutoRef`  | <sub>not yet implemented</sub> | points to a previous list
| `vAutoRef`  | <sub>not yet implemented</sub> | points to a previous voice
| `sAutoRef`  | <sub>not yet implemented</sub> | points to a previous score
| `pIterExpr` | <sub>not yet implemented</sub> | repeats and concatenates re-evaluations of a parameter function 
| `eIterExpr` | <sub>not yet implemented</sub> | repeats and concatenates re-evaluations of an event function 
| `lIterExpr` | <sub>not yet implemented</sub> | repeats and concatenates re-evaluations of a list function 
| `vIterExpr` | <sub>not yet implemented</sub> | repeats and concatenates re-evaluations of a voice function
| `sIterExpr` | <sub>not yet implemented</sub> | repeats and concatenates re-evaluations of a score function

---------
## External references
| name                   | index                          | description
| ---------------------- | ------------------------------ | -----------
| `sGenotypeFromLibrary` | <sub>not yet implemented</sub> | reads and inserts a genotype from an external library of genotypes
| `lTextfileData`        | <sub>not yet implemented</sub> | reads and inserts a list of values from an external textfile

---------
## Form
| name        | index                          | description
| ----------- | ------------------------------ | -----------
| `lConcatP`  | <sub>not yet implemented</sub> | concatenates two parameters sequentially
| `lConcatL`  | <sub>not yet implemented</sub> | concatenates two lists sequentially
| `vConcatE`  | <sub>not yet implemented</sub> | concatenates two events sequentially
| `vConcatV`  | <sub>not yet implemented</sub> | concatenates two voices sequentially
| `sConcatS`  | <sub>not yet implemented</sub> | concatenates two scores sequentially
| `eAddPitch` | <sub>not yet implemented</sub> | adds a pitch to an event
| `vRepeatE`  | <sub>not yet implemented</sub> | repeats an event a number of times
| `lRepeatL`  | <sub>not yet implemented</sub> | repeats a list a number of times
| `vRepeatV`  | <sub>not yet implemented</sub> | repeats a voice a number of times
| `sRepeatS`  | <sub>not yet implemented</sub> | repeats a score a number of times
| `lAAe`      | <sub>not yet implemented</sub> | single repetition of a parameter
| `lAAl`      | <sub>not yet implemented</sub> | single repetition of a list
| `vAAe`      | <sub>not yet implemented</sub> | single repetition of an event
| `vAAv`      | <sub>not yet implemented</sub> | single repetition of a voice
| `sAA`       | <sub>not yet implemented</sub> | single repetition of a score
| `lABAp`     | <sub>not yet implemented</sub> | A-B-A structure of parameters
| `lABAl`     | <sub>not yet implemented</sub> | A-B-A structure of lists
| `vABAe`     | <sub>not yet implemented</sub> | A-B-A structure of events
| `vABAv`     | <sub>not yet implemented</sub> | A-B-A structure of voices
| `sABA`      | <sub>not yet implemented</sub> | A-B-A structure of events
| `lABCABp`   | <sub>not yet implemented</sub> | A-B-C-B-A structure of parameters
| `lABCABl`   | <sub>not yet implemented</sub> | A-B-C-B-A structure of lists
| `vABCABe`   | <sub>not yet implemented</sub> | A-B-C-B-A structure of events
| `vABCABv`   | <sub>not yet implemented</sub> | A-B-C-B-A structure of voices
| `sABCAB`    | <sub>not yet implemented</sub> | A-B-C-B-A structure of events

---------
## Phrasing
| name                    | index                          | description
| ----------------------- | ------------------------------ | -----------
| `vInterval`             | <sub>not yet implemented</sub> | repeats previous note changing pitch according to an interval
| `vMotif`                | <sub>not yet implemented</sub> | creates a sequence of events based on lists
| `vMotifLoop`            | <sub>not yet implemented</sub> | creates a sequence of events based on repeating lists
| `vPerpetuumMobile`      | <sub>not yet implemented</sub> | creates a sequence of events based on repeating lists but with a single notevalue
| `vPerpetuumMobileLoop`  | <sub>not yet implemented</sub> | creates a sequence of events based on lists but with a single notevalue
| `vAcciaccatura`         | <sub>not yet implemented</sub> | adds an acciaccatura to an event
| `vAppoggiatura`         | <sub>not yet implemented</sub> | adds an appoggiatura to an event
| `vTrill`                | <sub>not yet implemented</sub> | converts an event in a trill of two pitches
| `vJitter`               | <sub>not yet implemented</sub> | converts an event in a group of randomly alterning pitches
| `vGliss`                | <sub>not yet implemented</sub> | connects two pitches with a scale (diatonic of chromatic)
| `sPedalNote`            | <sub>not yet implemented</sub> | adds a new voice consisting of a single sustained note to a score  
| `vArpeggio`             | <sub>not yet implemented</sub> | creates an arpeggio according to a harmonic grid
| `vProgression`          | <sub>not yet implemented</sub> | creates a progression repeating a motif at a transposition interval with chormatic transposition
| `vDiatonic Progression` | <sub>not yet implemented</sub> | creates a progression repeating a motif at a transposition interval adapting pitches to the harmonic grid
| `sEchoV`                | <sub>not yet implemented</sub> | adds a new voice repeating a voice at a time interval

---------
## Poliphony
| name            | index                          | description
| --------------- | ------------------------------ | -----------
| `eTwoPitches`   | <sub>not yet implemented</sub> | creates an event with two pitches
| `eThreePitches` | <sub>not yet implemented</sub> | creates an event with three pitches
| `eFourPitches`  | <sub>not yet implemented</sub> | creates an event with four pitches
| `eFivePitches`  | <sub>not yet implemented</sub> | creates an event with five pitches
| `eSixPitches`   | <sub>not yet implemented</sub> | creates an event with six pitches
| `eManyPitches`  | <sub>not yet implemented</sub> | creates an event with more than six pitches, with a maximal of 12 pitches
| `sTwoV`         | <sub>not yet implemented</sub> | creates an score with two simultaneous voices
| `sThreeV`       | <sub>not yet implemented</sub> | creates an score with three simultaneous voices
| `sFourV`        | <sub>not yet implemented</sub> | creates an score with four simultaneous voices
| `sFiveV`        | <sub>not yet implemented</sub> | creates an score with five simultaneous voices
| `sSixV`         | <sub>not yet implemented</sub> | creates an score with six simultaneous voices
| `sAddV`         | <sub>not yet implemented</sub> | adds a new voice vertically to a score
| `sAddS`         | <sub>not yet implemented</sub> | adds a new score vertically to a score

---------
## Counterpoint
| name                   | index                          | description
| ---------------------- | ------------------------------ | -----------
| `sFirstSpecies`        | <sub>not yet implemented</sub> | creates a new voice oposing an event against each event of a previous voice
| `sSecondSpecies`       | <sub>not yet implemented</sub> | creates a new voice oposing two events against each event of a previous voice
| `sSecondSpeciesInvert` | <sub>not yet implemented</sub> | creates a new voice oposing an event against each two events of a previous voice
| `sThirdSpecies`        | <sub>not yet implemented</sub> | creates a new voice oposing a fixed number of events (more than 2) against each event of a previous voice
| `sThirdSpeciesInvert`  | <sub>not yet implemented</sub> | creates a new voice oposing an event against a fixed number of events (more than 2) of a previous voice
| `sFourthSpecies`       | <sub>not yet implemented</sub> | creates a new voice oposing an event between each two events of a previous voice
| `sFifthSpecies`        | <sub>not yet implemented</sub> | creates a new voice adding a new voice that combines freely the first four species

---------
## Harmony
| name                   | index                          | description
| ---------------------- | ------------------------------ | -----------
| `vDiatonize`           | <sub>not yet implemented</sub> | diatonizes a voice according to a harmonic grid
| `sDiatonize`           | <sub>not yet implemented</sub> | diatonizes a score according to a harmonic grid
| `hChromaticScale`      | <sub>not yet implemented</sub> | returns a complete chromatic scale
| `hNaturalScale`        | <sub>not yet implemented</sub> | returns modes derived from the natural scale
| `hMelodicMinorScale`   | <sub>not yet implemented</sub> | returns modes derived from the melodic minor scale
| `hPentatonic`          | <sub>not yet implemented</sub> | returns modes derived from the major pentatonic scale
| `hBluesScale`          | <sub>not yet implemented</sub> | returns a pentatonic scale with blue notes
| `hJapanesePentatonic`  | <sub>not yet implemented</sub> | returns modes derived from japanese pentatonic scales
| `hHexatonicScale`      | <sub>not yet implemented</sub> | returns a whole tone scale
| `hOctatonicScale`      | <sub>not yet implemented</sub> | returns a half-whole diminished scale 
| `hLimitedTranspoScale` | <sub>not yet implemented</sub> | returns modes of limited transposition
| `hPCSet`               | <sub>not yet implemented</sub> | returns any mode generated by a list of pitches 
| `hCluster`             | <sub>not yet implemented</sub> | returns a group of consecutives chromatic tones
| `hOrientalizer`        | <sub>not yet implemented</sub> | takes a mode and transforms it moving notes in the middle of two consecutives whole tones to get 3 half-tone intervals.
| `hBebopizer`           | <sub>not yet implemented</sub> | takes a mode and returns it after inserting some chromatic steps
| `hDefectiveMode`       | <sub>not yet implemented</sub> | takes a mode and returns it after deleting some pitches 
| `hMajorChord`          | <sub>not yet implemented</sub> | returns a major chord 
| `hlMinorChord`         | <sub>not yet implemented</sub> | returns a minor chord 
| `hDominantChord`       | <sub>not yet implemented</sub> | returns a dominant seventh chord
| `hSeventhChord`        | <sub>not yet implemented</sub> | returns a four-note chord with triadic structure
| `hNinthChord`          | <sub>not yet implemented</sub> | returns a five-note chord with triadic structure
| `hTwoPitchesChord`     | <sub>not yet implemented</sub> | returns a pitch class sequence with two pitches 
| `hThreePCS`            | <sub>not yet implemented</sub> | returns a pitch class sequence with three pitches
| `hFourPCS`             | <sub>not yet implemented</sub> | returns a pitch class sequence with four pitches
| `hFivePCS`             | <sub>not yet implemented</sub> | returns a pitch class sequence with five pitches
| `hSixPCS`              | <sub>not yet implemented</sub> | returns a pitch class sequence with six pitches
| `lExpandChord`         | <sub>not yet implemented</sub> | takes a pitch class set and expands it across register, sometimes adding duplications
| `sHarmonizer`          | <sub>not yet implemented</sub> | takes a voice and add a new one simultaneously, at an specified interval and according to the current harmonic grid 

---------
## Rhythm
| name                | index                          | description
| ------------------- | ------------------------------ | -----------
| `vTempo`            | <sub>not yet implemented</sub> | changes the relative tempo of a voice 
| `sTempo`            | <sub>not yet implemented</sub> | changes the relative tempo of a score
| `vAccel`            | <sub>not yet implemented</sub> | accelerates tempo along a voice
| `sAccel`            | <sub>not yet implemented</sub> | accelerates tempo along a score
| `vRit`              | <sub>not yet implemented</sub> | slows tempo aling a voice
| `sRit`              | <sub>not yet implemented</sub> | slows tempo aling a score
| `vSimplifyRhythm`   | <sub>not yet implemented</sub> | reduces the rhythmic complexity of a voice
| `sSimplifyRhythm`   | <sub>not yet implemented</sub> | reduces the rhythmic complexity of a score
| `sIsorhythm`        | <sub>not yet implemented</sub> | forces a isorhythmic texture for all voices within a score

---------
## Articulation
| name                    | index                          | description
| ----------------------- | ------------------------------ | -----------
| `eMarcato`              | <sub>not yet implemented</sub> | changes the articulation/dynamics of an event to marcato
| `vLegatissimo`          | <sub>not yet implemented</sub> | changes all articulations within a voice to legatissimo
| `sLegatissimo`          | <sub>not yet implemented</sub> | changes all articulations within a score to legatissimo
| `vNonLegato`            | <sub>not yet implemented</sub> | changes all articulations within a voice to non-legato
| `sNonLegato`            | <sub>not yet implemented</sub> | changes all articulations within a score to non-legato
| `vLegato`               | <sub>not yet implemented</sub> | changes all articulations within a voice to legato
| `sLegato`               | <sub>not yet implemented</sub> | changes all articulations within a score to legato
| `vStaccato`             | <sub>not yet implemented</sub> | changes all articulations within a voice to staccato
| `sStaccato`             | <sub>not yet implemented</sub> | changes all articulations within a score to staccato
| `vStaccatissimo`        | <sub>not yet implemented</sub> | changes all articulations within a voice to staccatissimo
| `sStaccatissimo`        | <sub>not yet implemented</sub> | changes all articulations within a score to staccatissimo
| `sPedalSustain`         | <sub>not yet implemented</sub> | extends all articulations within a voice to simulate a pedal sustain
| `vShortenArticulations` | <sub>not yet implemented</sub> | shortens all articulations within a voice according to a factor
| `vProlongArticulations` | <sub>not yet implemented</sub> | extends all articulations within a voice according to a factor

---------
## Dynamics
| name         | index                          | description
| ------------ | ------------------------------ | -----------
| `eSforzando` | <sub>not yet implemented</sub> | changes the articulation/dynamics of an event to marcato
| `vCresc`     | <sub>not yet implemented</sub> | creates a crescendo in a voice
| `sCresc`     | <sub>not yet implemented</sub> | creates a crescendo in a score
| `vDim`       | <sub>not yet implemented</sub> | creates a diminuendo in a voice
| `sDim`       | <sub>not yet implemented</sub> | creates a diminuendo in a score
| `vLouder`    | <sub>not yet implemented</sub> | increments the global dynamics of a voice
| `sLouder`    | <sub>not yet implemented</sub> | increments the global dynamics of a score
| `vSofter`    | <sub>not yet implemented</sub> | reduces the global dynamics of a voice
| `sSofter`    | <sub>not yet implemented</sub> | reduces the global dynamics of a score
| `eMute`      | <sub>not yet implemented</sub> | reduces to 0 the dynamics of an event

---------
## Spectralism
| name                | index                          | description
| ------------------- | ------------------------------ | -----------
| `hHarmonicSeries`   | <sub>not yet implemented</sub> | returns a harmonic series
| `hSpectralMorphing` | <sub>not yet implemented</sub> | returns a harmonic series with some manipulations
| `vSpectralize`      | <sub>not yet implemented</sub> | adjusts the pitches of a voice to a harmonic series
| `sSpectralize`      | <sub>not yet implemented</sub> | adjusts the pitches of a score to a harmonic series

---------
## Serialism
| name                   | index                          | description
| ---------------------- | ------------------------------ | -----------
| `hDodecaphonicToneRow` | <sub>not yet implemented</sub> | returns a canonic dodecaphonic tone row
| `hUniquePitchesRow`    | <sub>not yet implemented</sub> | returns a row of 2 to 11 pitches without repetitions
| `eInvert`              | <sub>not yet implemented</sub> | inverts pitches of an event
| `vInvert`              | <sub>not yet implemented</sub> | inverts pitches of a voice
| `sInvert`              | <sub>not yet implemented</sub> | inverts pitches of a score
| `eTransp`              | <sub>not yet implemented</sub> | transposes pitches of an event
| `vTransp`              | <sub>not yet implemented</sub> | transposes pitches of a voice
| `sTransp`              | <sub>not yet implemented</sub> | transposes pitches of a score
| `eTranspOctav`         | <sub>not yet implemented</sub> | transposes pitches of an event only octaves
| `vTranspOctav`         | <sub>not yet implemented</sub> | transposes pitches of a voice only octaves
| `sTranspOctav`         | <sub>not yet implemented</sub> | transposes pitches of a score only octaves
| `vRetrog`              | <sub>not yet implemented</sub> | retrogrades pitches of a voice
| `sRetrog`              | <sub>not yet implemented</sub> | retrogrades pitches of a score
| `vRetrogInvert`        | <sub>not yet implemented</sub> | retrogrades and inverts pitches of a voice
| `sRetrogInvert`        | <sub>not yet implemented</sub> | retrogrades and inverts pitches of a score
| `eRotate`              | <sub>not yet implemented</sub> | rotates pitches of an event according to its intervallic structure
| `eExpand`              | <sub>not yet implemented</sub> | expands pitches of an event according to a factor
| `vExpand`              | <sub>not yet implemented</sub> | expands pitches of a voice according to a factor
| `sExpand`              | <sub>not yet implemented</sub> | expands pitches of a score according to a factor
| `vExtrude`             | <sub>not yet implemented</sub> | deforms pitches of a voice according to a curve
| `sExtrude`             | <sub>not yet implemented</sub> | deforms pitches of a score according to a curve

---------
## Aleatoric processes
| name               | index                          | description
| ------------------ | ------------------------------ | -----------
| `pRnd`             | <sub>not yet implemented</sub> | returns a random normalized parameter with uniform distribution
| `pGaussRnd`        | <sub>not yet implemented</sub> | returns a random normalized parameter with Gaussian (or normal) distribution
| `pWrappedGaussRnd` | <sub>not yet implemented</sub> | returns a random normalized parameter with a wrapped normal distribution
| `eRnd`             | <sub>not yet implemented</sub> | returns a complete random event with uniform distribution of parameters
| `eGaussRnd`        | <sub>not yet implemented</sub> | returns a complete random event with with Gaussian distribution of parameters
| `eWrappedGaussRnd` | <sub>not yet implemented</sub> | returns a complete random event with a wrapped normal distribution of parameters
| `lRnd`             | <sub>not yet implemented</sub> | returns a complete random list with uniform distribution of values
| `lGaussRnd`        | <sub>not yet implemented</sub> | returns a complete random list with with Gaussian distribution of parameters
| `lWrappedGaussRnd` | <sub>not yet implemented</sub> | returns a complete random list with a wrapped normal distribution of values
| `vRnd`             | <sub>not yet implemented</sub> | returns a complete random voice with uniform distribution of parameters
| `vGaussRnd`        | <sub>not yet implemented</sub> | returns a complete random voice with with Gaussian distribution of parameters
| `vWrappedGaussRnd` | <sub>not yet implemented</sub> | returns a complete random voice with a wrapped normal distribution of parameters
| `sRnd`             | <sub>not yet implemented</sub> | returns a complete random score with uniform distribution of parameters
| `sGaussRnd`        | <sub>not yet implemented</sub> | returns a complete random score with with Gaussian distribution of parameters
| `sWrappedGaussRnd` | <sub>not yet implemented</sub> | returns a complete random score with a wrapped normal distribution of parameters
| `pRndRange`        | <sub>not yet implemented</sub> | rescales a random normalized parameter to a new range
| `lRndDynamicRange` | <sub>not yet implemented</sub> | rescales a list of random values a changing range
| `eMutate`          | <sub>not yet implemented</sub> | changes parameters of an event according to probability and range of mutations
| `lMutate`          | <sub>not yet implemented</sub> | changes values of a list according to probability and range of mutations
| `vMutate`          | <sub>not yet implemented</sub> | changes parameters of a voice according to probability and range of mutations
| `sMutate`          | <sub>not yet implemented</sub> | changes parameters of a score according to probability and range of mutations
| `lPermutate`       | <sub>not yet implemented</sub> | permutates value positions of a list
| `vPermutate`       | <sub>not yet implemented</sub> | permutates events positions of a voice

---------
## Algorithmic techniques
| name                 | index                          | description
| -------------------- | ------------------------------ | -----------
| `lBrownian`          | <sub>not yet implemented</sub> | returns a list of values generated by a brownian movement
| `lMarkovChain`       | <sub>not yet implemented</sub> | returns a list of values generated by a Markov chain
| `lTuringMachine`     | <sub>not yet implemented</sub> | returns a list of values generated by a Turing machine
| `lLindenmayerSystem` | <sub>not yet implemented</sub> | returns a list of values generated by a Lindenmayer system
| `lHilbertCurve`      | <sub>not yet implemented</sub> | returns a list of values generated by a Hilbert curve
| `lCellularAutomata`  | <sub>not yet implemented</sub> | returns a list of values generated by iterating an automaton
| `lFibonacci`         | <sub>not yet implemented</sub> | returns a Fibonacci sequence starting with two initial 
| `lRecursion`         | <sub>not yet implemented</sub> | returns a sequence generated by a recursive formula
| `lLogisticMap`       | <sub>not yet implemented</sub> | returns a sequence generated with the logistic map
| `rEuclideanRhythm`   | <sub>not yet implemented</sub> | returns an Euclidean rhythmic grid

---------
## List manipulation
| name                | index                          | description
| ------------------- | ------------------------------ | -----------
| `lLine`             | <sub>not yet implemented</sub> | generates a straight progression between two values
| `lLinseg`           | <sub>not yet implemented</sub> | generates a series of straight segments between several values
| `lExpon`            | <sub>not yet implemented</sub> | generates an exponential progression between two values
| `lExpseg`           | <sub>not yet implemented</sub> | generates a series of exponential progressions between several values
| `lOscil`            | <sub>not yet implemented</sub> | generates a periodic sinusoidal oscillation between two values
| `lPhasor`           | <sub>not yet implemented</sub> | generates periodic straight transitions from first value to second one
| `lTriangular`       | <sub>not yet implemented</sub> | generates periodic straight transitions from first value to second one and vice versa
| `lRescale`          | <sub>not yet implemented</sub> | remaps a list to a new range  
| `lSmooth`           | <sub>not yet implemented</sub> | smooths distances between contiguous items in a list according to a factor
| `lRough`            | <sub>not yet implemented</sub> | sharpens distances between contiguous items in a list according to a factor
| `lInvert`           | <sub>not yet implemented</sub> | inverts values of a list
| `lTransp`           | <sub>not yet implemented</sub> | transposes values of a list
| `lRetrog`           | <sub>not yet implemented</sub> | retrogrades values of a list
| `lRetrogInvert`     | <sub>not yet implemented</sub> | retrogrades and inverts values of a list
| `lRotate`           | <sub>not yet implemented</sub> | rotates values of a list
| `lExpand`           | <sub>not yet implemented</sub> | expands values of a list according to a factor
| `lExtrude`          | <sub>not yet implemented</sub> | deforms values of a list according to a curve
| `lPolynomicGesture` | <sub>not yet implemented</sub> | generates a list by evaluating a polynomial
| `lBezierGesture`    | <sub>not yet implemented</sub> | generates a list based on a Bézier curve
| `lTrigonoGesture`   | <sub>not yet implemented</sub> | generates a list based on a trigonometric compound expression

---------
## Mathematical operations

*Explain how to deal with normalization*
 
| name       | index                          | description
| ---------- | ------------------------------ | -----------
| `oSum`     | <sub>not yet implemented</sub> | returns the sum of two values
| `oDiff`    | <sub>not yet implemented</sub> | returns the subtraction of two values
| `oMult`    | <sub>not yet implemented</sub> | returns the multiplication of two values
| `oDiv`     | <sub>not yet implemented</sub> | returns the quotient of two values
| `oMod`     | <sub>not yet implemented</sub> | returns the modulo (the remainder of the first value divided by the second one)
| `oPow`     | <sub>not yet implemented</sub> | returns an exponentiation using first value as base and second as exponent 
| `oLog`     | <sub>not yet implemented</sub> | returns the logarithm to base second value of the first value
| `oAbs`     | <sub>not yet implemented</sub> | returns the absolute value of the input
| `oFract`   | <sub>not yet implemented</sub> | returns the fractional value of the input
| `oFloor`   | <sub>not yet implemented</sub> | returns the greates integer less or equal to the input
| `oCeil`    | <sub>not yet implemented</sub> | returns the least integer greater or equal to the input
| `oSin`     | <sub>not yet implemented</sub> | returns the sine of a value
| `oCos`     | <sub>not yet implemented</sub> | returns the cosine of a value
| `oTan`     | <sub>not yet implemented</sub> | returns the tangent of a value
| `oArcsin`  | <sub>not yet implemented</sub> | returns the arcsine of a value
| `oArccos`  | <sub>not yet implemented</sub> | returns the arccosine of a value
| `oArctan`  | <sub>not yet implemented</sub> | returns the arctangent of a value
| `oSinh`    | <sub>not yet implemented</sub> | returns the hyperbolic sine of a value
| `oCosh`    | <sub>not yet implemented</sub> | returns the hyperbolic cosine of a value
| `oTanh`    | <sub>not yet implemented</sub> | returns the hyperbolic tangent of a value

---------
## Manual operators of genotypes 
| name       | index                          | description
| ---------- | ------------------------------ | -----------
| `uEVOLVE`  | <sub>not yet implemented</sub> | forces that all processes of evolution and mutation affects only the branch in which the function is inserted
| `uFREEZE`  | <sub>not yet implemented</sub> | blocks a genotype branch to exclude it from all processes of evolution and mutation 
| `uFLATTEN` | <sub>not yet implemented</sub> | renders a genotype branch and replace the branch with the encoded phenotype, so it will be not changed or evaluated anymore 
| `uEXTRACT` | <sub>not yet implemented</sub> | set boundaries on a score to allow transformations in only that part regardless of the score functional structure
| `uCUT`     | <sub>not yet implemented</sub> | set boundaries on a score and delete all events outside that section
| `uSAVE`    | <sub>not yet implemented</sub> | saves a genotype branch to an external library

---------
# Encoding-decoding genotypes

An encoded genotype is an unidimensional array of normalized values &isinv; [0, 1]. This encoded form is intended to be a pure numeric equivalent to the decoded genotype. The purpose of encoding is to provide an abstract representation of compositional procedures, suitable for different machine learning techniques such as evolutionary algorithms or neural networks.

---------
## Conversion table for genotypes

|  type                          | identifier        | value                  | example encoded &#x21C6; decoded 
| ------------------------------ | ----------------- | ---------------------- | ------------------------------------
| `)` or `),`                    | 0                 | -                      | `[0]` &#x21C6; `"),"`
| `]` or `],`                    | 0.2               | -                      | `[0.2]` &#x21C6; `"],"` 
| leaf <sub>paramF</sub>         | 0.5               | parameter              | `[0.5, 0.3]` &#x21C6; `"0.3"` 
| leaf <sub>notevalueF</sub>     | 0.51              | normalized parameter   | `[0.51, 0.3]` &#x21C6; `"1/32"` 
| leaf <sub>durationF</sub>      | 0.52              | normalized parameter   | `[0.52, 0.3]` &#x21C6; `"0.125"` 
| leaf <sub>midipitchF</sub>     | 0.53              | normalized parameter   | `[0.53, 0.3]` &#x21C6; `"42"` 
| leaf <sub>frequencyF</sub>     | 0.54              | normalized parameter   | `[0.54, 0.3]` &#x21C6; `"162"` 
| leaf <sub>articulationF</sub>  | 0.55              | normalized parameter   | `[0.55, 0.3]` &#x21C6; `"0.113708"` 
| leaf <sub>intensityF</sub>     | 0.56              | normalized parameter   | `[0.56, 0.3]` &#x21C6; `"38.1"` 
| leaf <sub>goldenintegerF</sub> | 0.57              | normalized parameter   | `[0.57, 0.3]` &#x21C6; `"514262"` 
| leaf <sub>quantizedF</sub>     | 0.58              | normalized parameter   | `[0.58, 0.3]` &#x21C6; `"-6"` 
| leaf <sub>*newtypeF*</sub>     | 0.2 < *x* < 0.8   | normalized parameter   | `[x, 0.3]` &#x21C6; human-readable converted value 
| `[`                            | 0.8               | -                      | `[0.8]` &#x21C6; `"["` 
| function name + `(`            | 1                 | encoded function index | `[1, 0.304952]` &#x21C6; `"vMotif("`

For each new function type its identifier must be close to 0.5, but different from the identifiers already used. 

----------
## Formatting decoded genotypes

Given the decoded expression 

`"funcNameA(0.3, funcNameB([0.1, 0.2, [0, 1], 0.3]), 0.2)"`, 

if the encoded function index of **funcNameA** and **funcNameB** were 0.123 and 0.456, the encoding process write 

`[1, 0.123, 0.5, 0.3, 1, 0.456, 0.8, 0.5, 0.1, 0.5, 0.2, 0.8, 0.5, 0, 0.5, 1, 0.2, 0, 0.5, 0.2, 0]`. 

Redecoding directly this last array produce

`"funcNameA(0.3,funcNameB([0.1,0.2,[0,1,],0.3,],),0.2,),"`.

Trailing commas after last element in enumerations and after closing parenthesis and brackets are removed when decoding encoded genotypes, resulting in:

`"funcNameA(0.3,funcNameB([0.1,0.2,[0,1],0.3]),0.2)"`.

When displaying decoded genotypes, further transformations are made to get better readability and editability:

```
"
funcNameA(
   0.3,
   funcNameB(
      [0.1, 0.2, [0, 1], 0.3]
   ),
   0.2,
)
"
```

---------
# Encoding-decoding phenotypes

A phenotype contains the music excerpt generated by a genotype in a similar way to the MIDI standard: it is list of events that can be transformed into a music score, or processed as audio with virtual instruments.

The format of an encoded phenotype is formally identical to an encoded genotype: both are a sequence of normalized floats whithin interval [0, 1]. As a consequence, encoded genotypes and phenotypes can be seen mathematically as the same type of object: n-dimensional vectors of real numbers within the interval [0, 1]. Furthermore, the evaluation of genotypes can be understood as a map that relates musical procedures to musical scores. This map is non-injective: different genotypes can generate the same phenotype, since diverse compositional processes can lead to the same result. At the same time, if the phenotype seed is changed, a genotype can generate many different phenotypes.

---------
## Encoded phenotype structure

| structure      | encoding
| -------------- | --------
| score          | `[1, <encodedVoice1>, <encodedVoice2>, ..., <encodedVoiceN, 0]`
| voice          | `[1, <encodedEvent1>, <encodedEvent2>, ..., <encodedEventN, 0]`
| event          | `[<eventParameter1>, <eventParameter2>, ...<eventParameterN>]` 
| multiparameter | `[<totalValues>, <value1>, <value2>, ..., <valueN>]`

- All phenotypes have the same hierarchical structure: events within a voice, and voices within a score. 
- Event data is listed as normalized values. Voices and scores are notated using numbers as flags: `1` and `0` indicate beginnings and endings of these wrappers.
- A score can consist of several concatenated scores (especially when their number of voices is different). For this reason it is necessary to use flags to connect them.
- The event data structure is predetermined by the [species characterization](#species-characterization).
- All event values are normalized according to predefined [parameter maps](#parameter-mapping). 
- If an event parameter uses more than one value, it is called *multiparameter*. The first float indicates the number of values needed (normalized as a [golden integer](#goldenintegerf-z)) followed by the values. 


---------
## Decoded phenotype

A decoded phenotype is any translation of an encoded phenotype readable for other software. Common formats for writing decoded phenotypes can be standard MIDI, MusicXML, Lilypond, readable messages for *bach.roll* and *bach.score* objects in Max, Csound, etc.



---------
# Examples of specimens

The following minimal examples illustrate several cases of conversion among encoded/decoded genotypes/phenotypes.

Decoded genotypes are automatically formatted for better readability and editability. They are equivalent to a compressed script without line breaks or tabs.  

All these examples belong to the default *piano* species. Phenotypes have been decoded into Lilypond language, but only the graphical rendering of this code is shown. 

---------
## Minimal specimen
#### Decoded genotype
##### Formatted
```
"
s(
   v(
      e(
         p(0.5),
         p(0.5),
         p(0.5),
         p(0.5)
      )
   ) 
)
"
```

##### Compressed
`"s(v(e(p(.5),p(.5),p(.5),p(.5))))"`

#### Encoded genotype
`[1, 0.472136, 1, 0.854102, 1, 0.236068, 1, 0, 0.5, 0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 0, 0.5, 0.5, 0, 0, 0, 0]`

#### Encoded phenotype
`[1, 1, 0.5, 0.618034, 0.5, 0.5, 0.5, 0, 0]`

#### Visualization of encoded genotype to encoded phenotype mapping

<sub>Visualizations map normalized values to grayscale (0=white, 1=black).</sub>

<img src="figures/visualization_ex1.svg" width="600">

#### Decoded phenotype

<img src="figures/ex1_score.svg" width="57">

---------
## Minimal specimen with human-readable leaf parameters

This table shows the encoding/decoding of lexical tokens in this example:

| decoded  | encoded
| -------- | -------
| `"s("`   | `[1, 0.472136]`
| `"v("`   | `[1, 0.854102]`
| `"e("`   | `[1, 0.236068]`
| `"n("`   | `[1, 0.09017]`
| `"1/16"` | `[0.51, 0.4]`
| `")"`    | `[0]`
| `"),"`   | `[0]`
| `"m("`   | `[1, 0.326238]`
| `"69"`   | `[0.53, 0.57]`
| `"a("`   | `[1, 0.562306]`
| `"0.4"`  | `[0.55, 0.248547]`
| `"i("`   | `[1, 0.18034]`
| `"80"`   | `[0.56, 0.629921]`

#### Decoded genotype
##### Formatted
```
"
s(
   v(
      e(
         n(1/16),
         m(69),
         a(0.4),
         i(80)
      )
   )   
)
"
```

##### Compressed
`"s(v(e(n(1/16),m(69),a(0.4),i(80))))"`

#### Encoded genotype
`[1, 0.472136, 1, 0.854102, 1, 0.236068, 1, 0.09017, 0.51, 0.4, 0, 1, 0.326238, 0.53, 0.57, 0, 1, 0.562306, 0.55, 0.248547, 0, 1, 0.18034, 0.56, 0.629921, 0, 0, 0, 0]`

#### Encoded phenotype
`[1, 1, 0.4, 0.618034, 0.57, 0.248547, 0.661417, 0, 0]`

#### Visualization

<img src="figures/visualization_ex2.svg" width="600">

#### Decoded phenotype

<img src="figures/ex2_score.svg" width="57">

---------
## Voice with lists

This example uses the function `vMotifLoop`<sub>.304952</sub> (as subscript, its encoded function number). This function which creates a sequence of events based on lists. The longest list determines how many events are rendered. Shorter lists are used as loops until the longest list length is reached.

The two lists in this genotype have been encoded as follows:

| decoded           | encoded
| ------------------| -------
| `"[1/2,1/4]"`     | `[0.8, 0.51, 0.7, 0.51, 0.6, 0.2]`
| `"[63,67,63,58]"` | `[0.8, 0.53, 0.51, 0.53, 0.55, 0.53, 0.51, 0.53, 0.46, 0.2]`

#### Decoded genotype
##### Formatted
```
"
s(
   vMotifLoop(
      ln([1/2,1/4]),
      lm([63,67,63,58]),
      a(1),
      i(42)
   )
)
"
```

##### Compressed
`"s(vMotifLoop(ln([1/2,1/4]),lm([63,67,63,58]),a(1),i(42)))"`

#### Encoded genotype
`[1, 0.472136, 1, 0.304952, 1, 0.27051, 0.8, 0.51, 0.7, 0.51, 0.6, 0.2, 0, 1, 0.506578, 0.8, 0.53, 0.51, 0.53, 0.55, 0.53, 0.51, 0.53, 0.46, 0.2, 0, 1, 0.562306, 0.55, 0.667539, 0, 1, 0.18034, 0.56, 0,330709, 0, 0, 0]` 

#### Encoded phenotype

`[1, 1, 0.7 ,0.618034, 0.51, 0.667539, 0.330709, 0.6 ,0.618034, 0.55, 0.667539, 0.330709, 0.7 ,0.618034, 0.51, 0.667539, 0.330709, 0.6 ,0.618034, 0.47, 0.667539, 0.330709, 0, 0]`

#### Visualization

<img src="figures/visualization_ex3.svg" width="800">

#### Decoded phenotype
<img src="figures/ex3_score.svg" width="140">

--------
## Multiple voices and multiple scores

The following example demostrate these concepts:

- A score can be made of many scores (only) sequentially concatenated.
- Poliphony is created adding voices vertically inside a score.

This example uses these functions:

- `sConcatS`<sub>.54102</sub>, which concatenates two scores sequentially.
- `sAddV`<sub>.159054</sub>, which adds a new voice vertically to a score.
- `vRepeatE`<sub>.777088</sub>, which repeats an event a number of times.

#### Decoded genotype
##### Formatted
```
"
sConcatS(    
   sAddV(
      sAddV(
         s(
            vRepeatE(
                e(
                  n(1/16),
                  lm([68,74,77]),
                  a(.2),
                  i(25)
                ),
                z(24)
            )
         ),
         vRepeatE(
            e(
               n(1/12),
               lm([62,65]),
               a(.2),
               i(15)
            ),
            z(18)
         )
      ),
      vMotifLoop(
         ln([1/2,1/4]),
         lm([53,56,53,46]),
         a(1),
         i(64)
      )
   ),
   sAddV(
      s(
         vMotifLoop(
            ln([1/2,1/4]),
            lm([63,67,63,58]),
            a(1),
            i(42)
         )
      ),
      vRepeatE(
         e(
            n(1/8),
            m(51),
            a(0.5),
            i(32)
         ),
         z(12)    
      )         
   ) 
)
"
```

##### Compressed
`"sConcatS(sAddV(sAddV(s(vRepeatE(e(n(1/16),lm([68,74,77]),a(.2),i(25)),z(24))),vRepeatE(e(n(1/12),lm([62,65]),a(.2),i(15)),z(18))),vMotifLoop(ln([1/2,1/4]),lm([53,56,53,46]),a(1),i(64))),sAddV(s(vMotifLoop(ln([1/2,1/4]),lm([63,67,63,58]),a(1),i(42))),vRepeatE(e(n(1/8),m(51),a(0.5),i(32)),z(12))))"`

#### Encoded genotype
`[1, 0.54102, 1, 0.159054, 1, 0.159054, 1, 0.472136, 1, 0.777088, 1, 0.236068, 1, 0.09017, 0.51, 0.4, 0, 1,  0.506578, 0.8, 0.53, 0.56, 0.53, 0.62, 0.53, 0.65, 0.2, 0, 1, 0.562306, 0.55, 0.369267, 0, 1, 0.18034, 0.56, 0.19685, 0, 0, 1, 0.798374, 0.57, 0.832816, 0, 0, 0, 1, 0.777088, 1, 0.236068, 1, 0.09017, 0.51, 0.441504, 0, 1,  0.506578, 0.8, 0.53, 0.5, 0.53, 0.53, 0.2, 0, 1, 0.562306, 0.55, 0.369267, 0, 1, 0.18034, 0.56, 0.11811, 0, 0, 1, 0.798374, 0.57, 0.124612, 0, 0, 0, 1, 0.304952, 1, 0.27051, 1, 0.8, 0.51, 0.7, 0.51, 0.61, 0.2, 0, 1,  0.506578, 0.8, 0.53, 0.41, 0.53, 0.44, 0.53, 0.41, 0.53, 0.34, 0.2, 0, 1, 0.562306, 0.55, 0.667539, 0, 1, 0.18034, 0.56, 0.503937, 0, 0, 0, 1, 0.159054, 1, 0.472136, 1, 0.304952, 1, 0.27051, 1, 0.8, 0.51, 0.7, 0.51, 0.61, 0.2, 0, 1,  0.506578, 0.8, 0.53, 0.51, 0.53, 0.55, 0.53, 0.51, 0.53, 0.461, 0.2, 0, 1, 0.562306, 0.55, 0.667539, 0, 1, 0.18034, 0.56, 0.330709, 0, 0, 0, 1, 0.777088, 1, 0.236068, 1, 0.09017, 0.51, 0.5, 0, 1, 0.326238, 0.53, 0.38, 0, 1, 0.562306, 0.55, 0.51729, 0, 1, 0.18034, 0.56, 0.251969, 0, 0, 1, 0.798374, 0.57, 0.416408, 0, 0, 0, 0]` 

#### Encoded phenotype

`[1, 1, 0.4, 0.854102, 0.56, 0.62, 0.65, 0.369267, 0.19685, 0.4, 0.854102, 0.56, 0.62, 0.65, 0.369267, 0.19685, 0.4, 0.854102, 0.56, 0.62, 0.65, 0.369267, 0.19685, 0.4, 0.854102, 0.56, 0.62, 0.65, 0.369267, 0.19685, 0.4, 0.854102, 0.56, 0.62, 0.65, 0.369267, 0.19685, 0.4, 0.854102, 0.56, 0.62, 0.65, 0.369267, 0.19685, 0.4, 0.854102, 0.56, 0.62, 0.65, 0.369267, 0.19685, 0.4, 0.854102, 0.56, 0.62, 0.65, 0.369267, 0.19685, 0.4, 0.854102, 0.56, 0.62, 0.65, 0.369267, 0.19685, 0.4, 0.854102, 0.56, 0.62, 0.65, 0.369267, 0.19685, 0.4, 0.854102, 0.56, 0.62, 0.65, 0.369267, 0.19685, 0.4, 0.854102, 0.56, 0.62, 0.65, 0.369267, 0.19685, 0.4, 0.854102, 0.56, 0.62, 0.65, 0.369267, 0.19685, 0.4, 0.854102, 0.56, 0.62, 0.65, 0.369267, 0.19685, 0.4, 0.854102, 0.56, 0.62, 0.65, 0.369267, 0.19685, 0.4, 0.854102, 0.56, 0.62, 0.65, 0.369267, 0.19685, 0.4, 0.854102, 0.56, 0.62, 0.65, 0.369267, 0.19685, 0.4, 0.854102, 0.56, 0.62, 0.65, 0.369267, 0.19685, 0.4, 0.854102, 0.56, 0.62, 0.65, 0.369267, 0.19685, 0.4, 0.854102, 0.56, 0.62, 0.65, 0.369267, 0.19685, 0.4, 0.854102, 0.56, 0.62, 0.65, 0.369267, 0.19685, 0.4, 0.854102, 0.56, 0.62, 0.65, 0.369267, 0.19685, 0.4, 0.854102, 0.56, 0.62, 0.65, 0.369267, 0.19685, 0.4, 0.854102, 0.56, 0.62, 0.65, 0.369267, 0.19685, 0, 1, 0.441504, 0.124612, 0.5, 0.53, 0.369267, 0.11811, 0.441504, 0.124612, 0.5, 0.53, 0.369267, 0.11811, 0.441504, 0.124612, 0.5, 0.53, 0.369267, 0.11811, 0.441504, 0.124612, 0.5, 0.53, 0.369267, 0.11811, 0.441504, 0.124612, 0.5, 0.53, 0.369267, 0.11811, 0.441504, 0.124612, 0.5, 0.53, 0.369267, 0.11811, 0.441504, 0.124612, 0.5, 0.53, 0.369267, 0.11811, 0.441504, 0.124612, 0.5, 0.53, 0.369267, 0.11811, 0.441504, 0.124612, 0.5, 0.53, 0.369267, 0.11811, 0.441504, 0.124612, 0.5, 0.53, 0.369267, 0.11811, 0.441504, 0.124612, 0.5, 0.53, 0.369267, 0.11811, 0.441504, 0.124612, 0.5, 0.53, 0.369267, 0.11811, 0, 1, 0.7, 0.618034, 0.41, 0.667539, 0.503937, 0.6, 0.618034, 0.44, 0.667539, 0.503937, 0.7, 0.618034, 0.41, 0.667539, 0.503937, 0.6, 0.618034, 0.34, 0.667539, 0.503937, 0, 0, 1, 1, 0.7, 0.618034, 0.51, 0.667539, 0.330709, 0.6, 0.618034, 0.55, 0.667539, 0.330709, 0.7, 0.618034, 0.51, 0.667539, 0.330709, 0.6, 0.618034, 0.46, 0.667539, 0.330709, 0, 1, 0.5, 0.618034, 0.38, 0.51729, 0.251969, 0.5, 0.618034, 0.38, 0.51729, 0.251969, 0.5, 0.618034, 0.38, 0.51729, 0.251969, 0.5, 0.618034, 0.38, 0.51729, 0.251969, 0.5, 0.618034, 0.38, 0.51729, 0.251969, 0.5, 0.618034, 0.38, 0.51729, 0.251969, 0.5, 0.618034, 0.38, 0.51729, 0.251969, 0.5, 0.618034, 0.38, 0.51729, 0.251969, 0.5, 0.618034, 0.38, 0.51729, 0.251969, 0.5, 0.618034, 0.38, 0.51729, 0.251969, 0.5, 0.618034, 0.38, 0.51729, 0.251969, 0.5, 0.618034, 0.38, 0.51729, 0.251969, 0, 0]`

#### Visualization

<img src="figures/visualization_ex4.svg" width="800">

#### Decoded phenotype
<img src="figures/ex4_score.svg" width="670">

---------
# Genotype substructures
## Branches and leaves

The genotype functional tree can be divided into **branches** and **leaves**. Genotype branches network is the function tree without leaves. This can be understood as the pure structure of compositional procedures regardless of the specific values of arguments. 

The set of leaves is the complementary information to the branches network: a list of every leaf value with a pointer to its position inside a genotype.  

Starting with this genotype, taken from [this example](#minimal-specimen-with-human-readable-leaf-parameters), 

`"s(v(e(n(1/16),m(69),a(0.4),i(80))))"`,

whose encoded equivalent is

`[1, 0.472136, 1, 0.854102, 1, 0.236068, 1, 0.09017, 0.51, 0.4, 0, 1, 0.326238, 0.53, 0.57, 0, 1, 0.562306, 0.55, 0.248547, 0, 1, 0.18034, 0.56, 0.629921, 0, 0, 0, 0]`,

is possible to extract an array of arrays with positions and values of leaves:

`[[9, 0.4],[14, 0.57],[19, 0.248547],[24, 0.629921]]`

Since all encoded leafs are normalized values, it is easy explore transformations of a genotype by manipulating them homogeneously, without distinguishing the type of parameter they represent, and injecting them back changing the corresponding positions of the encoded genotype.


---------
## Subexpressions

[golden conversion]

---------



---------
# Generation, evolution and selection of specimens 

--------- 
## Initial conditions for generation of genotypes

This table lists all information required for the process of generation, evaluation and selection of specimens. The default values can be modulated from the user interface. 

| initial condition  | description                                                              | default value
| ------------------ | ------------------------------------------------------------------------ | -------------
| maxGenotypeDepth   | Deepest level of ramification for new genotypes                          | 8
| minPhenotypeLength | Minimal number of events whithin the resulting phenotype                 | 1
| maxPhenotypeLength | Maximal number of events whithin the resulting phenotype                 | 1000
| maxIterations      | Maximal number of attempts to get a specimen that meets the requirements | 500


### Species characterization

The concept of species is crucial, because each species is determined by the parameter structure of a basic sonic event, and the functional arquitecture depends on this characterization. Specimens belonging to different species cannot be mixed without some kind of ad hoc adaptation. Consequently, an independent library must be created for each new species.

A species characterization must determine which mapping is employed for the decoding of each parameter. 

The default species of GenoMus, called *piano*, uses this event parameter structure:

`[<notevalueF>, <n>, <midipitchF_1>, <midipitchF_2>, ..., <midipitch_n>, <articulationF>, <intensityF>]`

The second parameter is a **midipitchF** *multiparameter*, which begins with _**n**_ as the total number of midipitch values (written as an encoded golden integer) followed by the series of values.

For each parameter, decoded phenotypes use the [conversion rules](#parameter-mapping) of the invoked function types.



---------
### Eligible functions

- Format for specifying eligible functions
- Format for specifying not eligible functions

---------
### Mandatory functions

- Format for specifying mandatory functions

---------
### Vector of desired musical characteristics

- Format for determine desired musical features and weights
  - **"polyphony"**
  - **"rhythmicComplexity"**
  - **"chromatism"**
  - **"disonance"**
  - **"disjunctivity"**
  - **"modalChroma"**
  - **"tonalStability"**
  - **"tessituraDispersion"**
  - **"variability"**: measures how much use of repetition is made.
  - **"articulationHomogeneity"**
  - **"dynamicHomogeneity"**
  
#### Weighted measurement of Euclidean distance

- Formula to measure distance of a phenotype to the goal vector

---------
## Creation of new genotypes

*Creative cycle flowchart*

### Generating encoded genoypes from random values

Universal random search space. All vectors are a valid input.

### Self-references
### Mutation

--------- 
## Specimen data structure

All generated specimens are stored as temporary JSON files. Selected specimens are permanently saved as JSON files in the Specimen catalogue. These JSON files are created according to the following data structure:

- **"metadata"**: data to identify and classify the specimen within the catalogue.
  - **"specimenID"**: unique specimen identificator base on date of creation compressed as a unique number and usersname.
  - **"permalink**: permanent link to the JSON file of the specimen (only for selected specimens, not for temporary ones).
  - **"GenoMusVersion"**: GenoMus version that generated the specimen.
  - **"creationTimecode"**: creation date compressed as a unique number.
  - **"user"**: username.
  - **"species"**: name of the species (given by user).
  - **"eventParameters"**: event parameters structure defining the basic sonic events.
  - **"globalRating"**: average of aesthetic ratings obtained.
  - **"iterations"**: number of iterations of the algorithm until finding this specimen.
  - **"millisecondsElapsed"**: time elapsed until finding this specimen.
  - **"encGenotypeLength"**: length of the float array contaning the encoded genotype. 
  - **"encPhenotypeLength"**: length of the float array contaning the encoded phenotype.
  - **"decPhenotypeDuration"**: total duration of the generated piece in seconds.
  - **"depth"**: deepest level of ramification of the decoded genotype function tree.
  - **"totalFunctions**: total of different functions used.    
  - **"selfReference"**: measures reuse of internal substructures.  
- **"initialConditions"**: set of initial conditions to satisfy by the generative process [(more info)](#initial-conditions-for-generation-of-genotypes).
  - **"eligibleFunctions"**: numeric array containing the eligible functions for genotype generation.
  - **"maxGenotypeDepth"**
  - **"minPhenotypeLength"**
  - **"maxPhenotypeLength"**
  - **"maxIterations"**: maximal number of attempts before the generative process stops 
  - **"heuristics"**: weigthed list of desired features, similar to those in "automaticAnalysis" (see below).
  - **"genotypeSeed"**
  - **"phenotypeSeed"**
- **"encodedGenotype"**: array of floats &isinv; [0, 1].
- **"decodedGenotype"**: string containing the genotype function tree.
- **"formattedGenotype"**: string containing the decoded genotype, formatted with blanks and line breaks to clearly display the function tree.
- **"leaves"**: array with all leaf values and their corresponding position in the encoded genotype. 
- **"subexpressions"**: list of all functional substructures within a genotype, enumerated by output type and order of appearance.
  - **"scoreF"**: subexpressions whose output is of type score.
  - **"voiceF"**: ...
  - **"eventF"**
  - **"listF"**
  - **"paramF"**
  - **"harmonyF"**
  - ...
- **"encodedPhenotype"**: array of floats &isinv; [0, 1].
- **"decodedPhenotype"**: phenotype converted to the desired formats (bach roll, bach score, lilypond, MusicXML, Csound, multimedia outputs, etc.)
- **"automaticAnalysis"**: automatic analysis of many different musical characteristics of the specimen, each one expressed as a normalized value &isinv; [0, 1]. A higher number means more complexity.  
  - **"polyphony"**
  - **"rhythmicComplexity"**
  - **"chromatism"**
  - **"disonance"**
  - **"disjunctivity"**
  - **"modalChroma"**
  - **"tonalStability"**
  - **"tessituraDispersion"**
  - **"variability"**: measures how much use of repetition is made.
  - **"articulationHomogeneity"**
  - **"dynamicHomogeneity"**
- **"humanEvaluation"**: human evaluation of different musical, aesthetic and emotional aspects of the specimen. This item can store the assessment of many different users. 
  - **"aestheticValue"**
  - **"mood"**: emotional resonances, expressed as a vector of different axes (to be defined).
  - **"originality"**
  - **"predictability"**

---------
## Specimen catalogue
### Naming
### Classification
### Catalogue access

---------
# Max user interface